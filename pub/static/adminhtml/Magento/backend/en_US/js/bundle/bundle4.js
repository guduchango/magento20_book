require.config({
    config: {
        'jsbuild':{"jquery/fileUploader/jquery.fileupload.js":"/*\n * jQuery File Upload Plugin 5.16.4\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n */\n\n/*jslint nomen: true, unparam: true, regexp: true */\n/*global define, window, document, Blob, FormData, location */\n\n(function (factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        // Register as an anonymous AMD module:\n        define([\n            'jquery',\n            'jquery/ui',\n            'jquery/fileUploader/jquery.iframe-transport'\n        ], factory);\n    } else {\n        // Browser globals:\n        factory(window.jQuery);\n    }\n}(function ($) {\n    'use strict';\n\n    // The FileReader API is not actually used, but works as feature detection,\n    // as e.g. Safari supports XHR file uploads via the FormData API,\n    // but not non-multipart XHR file uploads:\n    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);\n    $.support.xhrFormDataFileUpload = !!window.FormData;\n\n    // The fileupload widget listens for change events on file input fields defined\n    // via fileInput setting and paste or drop events of the given dropZone.\n    // In addition to the default jQuery Widget methods, the fileupload widget\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\n    // the fileupload API.\n    // By default, files added via file input selection, paste, drag & drop or\n    // \"add\" method are uploaded immediately, but it is possible to override\n    // the \"add\" callback option to queue file uploads.\n    $.widget('blueimp.fileupload', {\n\n        options: {\n            // The namespace used for event handler binding on the dropZone and\n            // fileInput collections.\n            // If not set, the name of the widget (\"fileupload\") is used.\n            namespace: undefined,\n            // The drop target collection, by the default the complete document.\n            // Set to null or an empty collection to disable drag & drop support:\n            dropZone: $(document),\n            // The file input field collection, that is listened for change events.\n            // If undefined, it is set to the file input fields inside\n            // of the widget element on plugin initialization.\n            // Set to null or an empty collection to disable the change listener.\n            fileInput: undefined,\n            // By default, the file input field is replaced with a clone after\n            // each input field change event. This is required for iframe transport\n            // queues and allows change events to be fired for the same file\n            // selection, but can be disabled by setting the following option to false:\n            replaceFileInput: true,\n            // The parameter name for the file form data (the request argument name).\n            // If undefined or empty, the name property of the file input field is\n            // used, or \"files[]\" if the file input name property is also empty,\n            // can be a string or an array of strings:\n            paramName: undefined,\n            // By default, each file of a selection is uploaded using an individual\n            // request for XHR type uploads. Set to false to upload file\n            // selections in one request each:\n            singleFileUploads: true,\n            // To limit the number of files uploaded with one XHR request,\n            // set the following option to an integer greater than 0:\n            limitMultiFileUploads: undefined,\n            // Set the following option to true to issue all file upload requests\n            // in a sequential order:\n            sequentialUploads: false,\n            // To limit the number of concurrent uploads,\n            // set the following option to an integer greater than 0:\n            limitConcurrentUploads: undefined,\n            // Set the following option to true to force iframe transport uploads:\n            forceIframeTransport: false,\n            // Set the following option to the location of a redirect url on the\n            // origin server, for cross-domain iframe transport uploads:\n            redirect: undefined,\n            // The parameter name for the redirect url, sent as part of the form\n            // data and set to 'redirect' if this option is empty:\n            redirectParamName: undefined,\n            // Set the following option to the location of a postMessage window,\n            // to enable postMessage transport uploads:\n            postMessage: undefined,\n            // By default, XHR file uploads are sent as multipart/form-data.\n            // The iframe transport is always using multipart/form-data.\n            // Set to false to enable non-multipart XHR uploads:\n            multipart: true,\n            // To upload large files in smaller chunks, set the following option\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\n            // or the browser does not support the required Blob API, files will\n            // be uploaded as a whole.\n            maxChunkSize: undefined,\n            // When a non-multipart upload or a chunked multipart upload has been\n            // aborted, this option can be used to resume the upload by setting\n            // it to the size of the already uploaded bytes. This option is most\n            // useful when modifying the options object inside of the \"add\" or\n            // \"send\" callbacks, as the options are cloned for each file upload.\n            uploadedBytes: undefined,\n            // By default, failed (abort or error) file uploads are removed from the\n            // global progress calculation. Set the following option to false to\n            // prevent recalculating the global progress data:\n            recalculateProgress: true,\n            // Interval in milliseconds to calculate and trigger progress events:\n            progressInterval: 100,\n            // Interval in milliseconds to calculate progress bitrate:\n            bitrateInterval: 500,\n\n            // Additional form data to be sent along with the file uploads can be set\n            // using this option, which accepts an array of objects with name and\n            // value properties, a function returning such an array, a FormData\n            // object (for XHR file uploads), or a simple object.\n            // The form of the first fileInput is given as parameter to the function:\n            formData: function (form) {\n                return form.serializeArray();\n            },\n\n            // The add callback is invoked as soon as files are added to the fileupload\n            // widget (via file input selection, drag & drop, paste or add API call).\n            // If the singleFileUploads option is enabled, this callback will be\n            // called once for each file in the selection for XHR file uplaods, else\n            // once for each file selection.\n            // The upload starts when the submit method is invoked on the data parameter.\n            // The data object contains a files property holding the added files\n            // and allows to override plugin options as well as define ajax settings.\n            // Listeners for this callback can also be bound the following way:\n            // .bind('fileuploadadd', func);\n            // data.submit() returns a Promise object and allows to attach additional\n            // handlers using jQuery's Deferred callbacks:\n            // data.submit().done(func).fail(func).always(func);\n            add: function (e, data) {\n                data.submit();\n            },\n\n            // Other callbacks:\n            // Callback for the submit event of each file upload:\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\n            // Callback for the start of each file upload request:\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\n            // Callback for successful uploads:\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\n            // Callback for failed (abort or error) uploads:\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\n            // Callback for completed (success, abort or error) requests:\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\n            // Callback for upload progress events:\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\n            // Callback for global upload progress events:\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\n            // Callback for uploads start, equivalent to the global ajaxStart event:\n            // start: function (e) {}, // .bind('fileuploadstart', func);\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\n            // Callback for change events of the fileInput collection:\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\n            // Callback for paste events to the dropZone collection:\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\n            // Callback for drop events of the dropZone collection:\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\n            // Callback for dragover events of the dropZone collection:\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\n\n            // The plugin options are used as settings object for the ajax calls.\n            // The following are jQuery ajax settings required for the file uploads:\n            processData: false,\n            contentType: false,\n            cache: false\n        },\n\n        // A list of options that require a refresh after assigning a new value:\n        _refreshOptionsList: [\n            'namespace',\n            'dropZone',\n            'fileInput',\n            'multipart',\n            'forceIframeTransport'\n        ],\n\n        _BitrateTimer: function () {\n            this.timestamp = +(new Date());\n            this.loaded = 0;\n            this.bitrate = 0;\n            this.getBitrate = function (now, loaded, interval) {\n                var timeDiff = now - this.timestamp;\n                if (!this.bitrate || !interval || timeDiff > interval) {\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\n                    this.loaded = loaded;\n                    this.timestamp = now;\n                }\n                return this.bitrate;\n            };\n        },\n\n        _isXHRUpload: function (options) {\n            return !options.forceIframeTransport &&\n                ((!options.multipart && $.support.xhrFileUpload) ||\n                $.support.xhrFormDataFileUpload);\n        },\n\n        _getFormData: function (options) {\n            var formData;\n            if (typeof options.formData === 'function') {\n                return options.formData(options.form);\n            }\n\t\t\tif ($.isArray(options.formData)) {\n                return options.formData;\n            }\n\t\t\tif (options.formData) {\n                formData = [];\n                $.each(options.formData, function (name, value) {\n                    formData.push({name: name, value: value});\n                });\n                return formData;\n            }\n            return [];\n        },\n\n        _getTotal: function (files) {\n            var total = 0;\n            $.each(files, function (index, file) {\n                total += file.size || 1;\n            });\n            return total;\n        },\n\n        _onProgress: function (e, data) {\n            if (e.lengthComputable) {\n                var now = +(new Date()),\n                    total,\n                    loaded;\n                if (data._time && data.progressInterval &&\n                        (now - data._time < data.progressInterval) &&\n                        e.loaded !== e.total) {\n                    return;\n                }\n                data._time = now;\n                total = data.total || this._getTotal(data.files);\n                loaded = parseInt(\n                    e.loaded / e.total * (data.chunkSize || total),\n                    10\n                ) + (data.uploadedBytes || 0);\n                this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);\n                data.lengthComputable = true;\n                data.loaded = loaded;\n                data.total = total;\n                data.bitrate = data._bitrateTimer.getBitrate(\n                    now,\n                    loaded,\n                    data.bitrateInterval\n                );\n                // Trigger a custom progress event with a total data property set\n                // to the file size(s) of the current upload and a loaded data\n                // property calculated accordingly:\n                this._trigger('progress', e, data);\n                // Trigger a global progress event for all current file uploads,\n                // including ajax calls queued for sequential file uploads:\n                this._trigger('progressall', e, {\n                    lengthComputable: true,\n                    loaded: this._loaded,\n                    total: this._total,\n                    bitrate: this._bitrateTimer.getBitrate(\n                        now,\n                        this._loaded,\n                        data.bitrateInterval\n                    )\n                });\n            }\n        },\n\n        _initProgressListener: function (options) {\n            var that = this,\n                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\n            // Accesss to the native XHR object is required to add event listeners\n            // for the upload progress event:\n            if (xhr.upload) {\n                $(xhr.upload).bind('progress', function (e) {\n                    var oe = e.originalEvent;\n                    // Make sure the progress event properties get copied over:\n                    e.lengthComputable = oe.lengthComputable;\n                    e.loaded = oe.loaded;\n                    e.total = oe.total;\n                    that._onProgress(e, options);\n                });\n                options.xhr = function () {\n                    return xhr;\n                };\n            }\n        },\n\n        _initXHRData: function (options) {\n            var formData,\n                file = options.files[0],\n                // Ignore non-multipart setting if not supported:\n                multipart = options.multipart || !$.support.xhrFileUpload,\n                paramName = options.paramName[0];\n            if (!multipart || options.blob) {\n                // For non-multipart uploads and chunked uploads,\n                // file meta data is not part of the request body,\n                // so we transmit this data as part of the HTTP headers.\n                // For cross domain requests, these headers must be allowed\n                // via Access-Control-Allow-Headers or removed using\n                // the beforeSend callback:\n                options.headers = $.extend(options.headers, {\n                    'X-File-Name': file.name,\n                    'X-File-Type': file.type,\n                    'X-File-Size': file.size\n                });\n                if (!options.blob) {\n                    // Non-chunked non-multipart upload:\n                    options.contentType = file.type;\n                    options.data = file;\n                } else if (!multipart) {\n                    // Chunked non-multipart upload:\n                    options.contentType = 'application/octet-stream';\n                    options.data = options.blob;\n                }\n            }\n            if (multipart && $.support.xhrFormDataFileUpload) {\n                if (options.postMessage) {\n                    // window.postMessage does not allow sending FormData\n                    // objects, so we just add the File/Blob objects to\n                    // the formData array and let the postMessage window\n                    // create the FormData object out of this array:\n                    formData = this._getFormData(options);\n                    if (options.blob) {\n                        formData.push({\n                            name: paramName,\n                            value: options.blob\n                        });\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            formData.push({\n                                name: options.paramName[index] || paramName,\n                                value: file\n                            });\n                        });\n                    }\n                } else {\n                    if (options.formData instanceof FormData) {\n                        formData = options.formData;\n                    } else {\n                        formData = new FormData();\n                        $.each(this._getFormData(options), function (index, field) {\n                            formData.append(field.name, field.value);\n                        });\n                    }\n                    if (options.blob) {\n                        formData.append(paramName, options.blob, file.name);\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            // File objects are also Blob instances.\n                            // This check allows the tests to run with\n                            // dummy objects:\n                            if (file instanceof Blob) {\n                                formData.append(\n                                    options.paramName[index] || paramName,\n                                    file,\n                                    file.name\n                                );\n                            }\n                        });\n                    }\n                }\n                options.data = formData;\n            }\n            // Blob reference is not needed anymore, free memory:\n            options.blob = null;\n        },\n\n        _initIframeSettings: function (options) {\n            // Setting the dataType to iframe enables the iframe transport:\n            options.dataType = 'iframe ' + (options.dataType || '');\n            // The iframe transport accepts a serialized array as form data:\n            options.formData = this._getFormData(options);\n            // Add redirect url to form data on cross-domain uploads:\n            if (options.redirect && $('<a></a>').prop('href', options.url)\n                    .prop('host') !== location.host) {\n                options.formData.push({\n                    name: options.redirectParamName || 'redirect',\n                    value: options.redirect\n                });\n            }\n        },\n\n        _initDataSettings: function (options) {\n            if (this._isXHRUpload(options)) {\n                if (!this._chunkedUpload(options, true)) {\n                    if (!options.data) {\n                        this._initXHRData(options);\n                    }\n                    this._initProgressListener(options);\n                }\n                if (options.postMessage) {\n                    // Setting the dataType to postmessage enables the\n                    // postMessage transport:\n                    options.dataType = 'postmessage ' + (options.dataType || '');\n                }\n            } else {\n                this._initIframeSettings(options, 'iframe');\n            }\n        },\n\n        _getParamName: function (options) {\n            var fileInput = $(options.fileInput),\n                paramName = options.paramName;\n            if (!paramName) {\n                paramName = [];\n                fileInput.each(function () {\n                    var input = $(this),\n                        name = input.prop('name') || 'files[]',\n                        i = (input.prop('files') || [1]).length;\n                    while (i) {\n                        paramName.push(name);\n                        i -= 1;\n                    }\n                });\n                if (!paramName.length) {\n                    paramName = [fileInput.prop('name') || 'files[]'];\n                }\n            } else if (!$.isArray(paramName)) {\n                paramName = [paramName];\n            }\n            return paramName;\n        },\n\n        _initFormSettings: function (options) {\n            // Retrieve missing options from the input field and the\n            // associated form, if available:\n            if (!options.form || !options.form.length) {\n                options.form = $(options.fileInput.prop('form'));\n            }\n            options.paramName = this._getParamName(options);\n            if (!options.url) {\n                options.url = options.form.prop('action') || location.href;\n            }\n            // The HTTP request method must be \"POST\" or \"PUT\":\n            options.type = (options.type || options.form.prop('method') || '')\n                .toUpperCase();\n            if (options.type !== 'POST' && options.type !== 'PUT') {\n                options.type = 'POST';\n            }\n            if (!options.formAcceptCharset) {\n                options.formAcceptCharset = options.form.attr('accept-charset');\n            }\n        },\n\n        _getAJAXSettings: function (data) {\n            var options = $.extend({}, this.options, data);\n            this._initFormSettings(options);\n            this._initDataSettings(options);\n            return options;\n        },\n\n        // Maps jqXHR callbacks to the equivalent\n        // methods of the given Promise object:\n        _enhancePromise: function (promise) {\n            promise.success = promise.done;\n            promise.error = promise.fail;\n            promise.complete = promise.always;\n            return promise;\n        },\n\n        // Creates and returns a Promise object enhanced with\n        // the jqXHR methods abort, success, error and complete:\n        _getXHRPromise: function (resolveOrReject, context, args) {\n            var dfd = $.Deferred(),\n                promise = dfd.promise();\n            context = context || this.options.context || promise;\n            if (resolveOrReject === true) {\n                dfd.resolveWith(context, args);\n            } else if (resolveOrReject === false) {\n                dfd.rejectWith(context, args);\n            }\n            promise.abort = dfd.promise;\n            return this._enhancePromise(promise);\n        },\n\n        // Uploads a file in multiple, sequential requests\n        // by splitting the file up in multiple blob chunks.\n        // If the second parameter is true, only tests if the file\n        // should be uploaded in chunks, but does not invoke any\n        // upload requests:\n        _chunkedUpload: function (options, testOnly) {\n            var that = this,\n                file = options.files[0],\n                fs = file.size,\n                ub = options.uploadedBytes = options.uploadedBytes || 0,\n                mcs = options.maxChunkSize || fs,\n                // Use the Blob methods with the slice implementation\n                // according to the W3C Blob API specification:\n                slice = file.webkitSlice || file.mozSlice || file.slice,\n                upload,\n                n,\n                jqXHR,\n                pipe;\n            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||\n                    options.data) {\n                return false;\n            }\n            if (testOnly) {\n                return true;\n            }\n            if (ub >= fs) {\n                file.error = 'uploadedBytes';\n                return this._getXHRPromise(\n                    false,\n                    options.context,\n                    [null, 'error', file.error]\n                );\n            }\n            // n is the number of blobs to upload,\n            // calculated via filesize, uploaded bytes and max chunk size:\n            n = Math.ceil((fs - ub) / mcs);\n            // The chunk upload method accepting the chunk number as parameter:\n            upload = function (i) {\n                if (!i) {\n                    return that._getXHRPromise(true, options.context);\n                }\n                // Upload the blobs in sequential order:\n                return upload(i -= 1).pipe(function () {\n                    // Clone the options object for each chunk upload:\n                    var o = $.extend({}, options);\n                    o.blob = slice.call(\n                        file,\n                        ub + i * mcs,\n                        ub + (i + 1) * mcs\n                    );\n                    // Expose the chunk index:\n                    o.chunkIndex = i;\n                    // Expose the number of chunks:\n                    o.chunksNumber = n;\n                    // Store the current chunk size, as the blob itself\n                    // will be dereferenced after data processing:\n                    o.chunkSize = o.blob.size;\n                    // Process the upload data (the blob and potential form data):\n                    that._initXHRData(o);\n                    // Add progress listeners for this chunk upload:\n                    that._initProgressListener(o);\n                    jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context))\n                        .done(function () {\n                            // Create a progress event if upload is done and\n                            // no progress event has been invoked for this chunk:\n                            if (!o.loaded) {\n                                that._onProgress($.Event('progress', {\n                                    lengthComputable: true,\n                                    loaded: o.chunkSize,\n                                    total: o.chunkSize\n                                }), o);\n                            }\n                            options.uploadedBytes = o.uploadedBytes +=\n                                o.chunkSize;\n                        });\n                    return jqXHR;\n                });\n            };\n            // Return the piped Promise object, enhanced with an abort method,\n            // which is delegated to the jqXHR object of the current upload,\n            // and jqXHR callbacks mapped to the equivalent Promise methods:\n            pipe = upload(n);\n            pipe.abort = function () {\n                return jqXHR.abort();\n            };\n            return this._enhancePromise(pipe);\n        },\n\n        _beforeSend: function (e, data) {\n            if (this._active === 0) {\n                // the start callback is triggered when an upload starts\n                // and no other uploads are currently running,\n                // equivalent to the global ajaxStart event:\n                this._trigger('start');\n                // Set timer for global bitrate progress calculation:\n                this._bitrateTimer = new this._BitrateTimer();\n            }\n            this._active += 1;\n            // Initialize the global progress values:\n            this._loaded += data.uploadedBytes || 0;\n            this._total += this._getTotal(data.files);\n        },\n\n        _onDone: function (result, textStatus, jqXHR, options) {\n            if (!this._isXHRUpload(options)) {\n                // Create a progress event for each iframe load:\n                this._onProgress($.Event('progress', {\n                    lengthComputable: true,\n                    loaded: 1,\n                    total: 1\n                }), options);\n            }\n            options.result = result;\n            options.textStatus = textStatus;\n            options.jqXHR = jqXHR;\n            this._trigger('done', null, options);\n        },\n\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\n            options.jqXHR = jqXHR;\n            options.textStatus = textStatus;\n            options.errorThrown = errorThrown;\n            this._trigger('fail', null, options);\n            if (options.recalculateProgress) {\n                // Remove the failed (error or abort) file upload from\n                // the global progress calculation:\n                this._loaded -= options.loaded || options.uploadedBytes || 0;\n                this._total -= options.total || this._getTotal(options.files);\n            }\n        },\n\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\n            this._active -= 1;\n            options.textStatus = textStatus;\n            if (jqXHRorError && jqXHRorError.always) {\n                options.jqXHR = jqXHRorError;\n                options.result = jqXHRorResult;\n            } else {\n                options.jqXHR = jqXHRorResult;\n                options.errorThrown = jqXHRorError;\n            }\n            this._trigger('always', null, options);\n            if (this._active === 0) {\n                // The stop callback is triggered when all uploads have\n                // been completed, equivalent to the global ajaxStop event:\n                this._trigger('stop');\n                // Reset the global progress values:\n                this._loaded = this._total = 0;\n                this._bitrateTimer = null;\n            }\n        },\n\n        _onSend: function (e, data) {\n            var that = this,\n                jqXHR,\n                slot,\n                pipe,\n                options = that._getAJAXSettings(data),\n                send = function (resolve, args) {\n                    that._sending += 1;\n                    // Set timer for bitrate progress calculation:\n                    options._bitrateTimer = new that._BitrateTimer();\n                    jqXHR = jqXHR || (\n                        (resolve !== false &&\n                        that._trigger('send', e, options) !== false &&\n                        (that._chunkedUpload(options) || $.ajax(options))) ||\n                        that._getXHRPromise(false, options.context, args)\n                    ).done(function (result, textStatus, jqXHR) {\n                        that._onDone(result, textStatus, jqXHR, options);\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n                        that._onFail(jqXHR, textStatus, errorThrown, options);\n                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\n                        that._sending -= 1;\n                        that._onAlways(\n                            jqXHRorResult,\n                            textStatus,\n                            jqXHRorError,\n                            options\n                        );\n                        if (options.limitConcurrentUploads &&\n                                options.limitConcurrentUploads > that._sending) {\n                            // Start the next queued upload,\n                            // that has not been aborted:\n                            var nextSlot = that._slots.shift(),\n                                isPending;\n                            while (nextSlot) {\n                                // jQuery 1.6 doesn't provide .state(),\n                                // while jQuery 1.8+ removed .isRejected():\n                                isPending = nextSlot.state ?\n                                        nextSlot.state() === 'pending' :\n                                        !nextSlot.isRejected();\n                                if (isPending) {\n                                    nextSlot.resolve();\n                                    break;\n                                }\n                                nextSlot = that._slots.shift();\n                            }\n                        }\n                    });\n                    return jqXHR;\n                };\n            this._beforeSend(e, options);\n            if (this.options.sequentialUploads ||\n                    (this.options.limitConcurrentUploads &&\n                    this.options.limitConcurrentUploads <= this._sending)) {\n                if (this.options.limitConcurrentUploads > 1) {\n                    slot = $.Deferred();\n                    this._slots.push(slot);\n                    pipe = slot.pipe(send);\n                } else {\n                    pipe = (this._sequence = this._sequence.pipe(send, send));\n                }\n                // Return the piped Promise object, enhanced with an abort method,\n                // which is delegated to the jqXHR object of the current upload,\n                // and jqXHR callbacks mapped to the equivalent Promise methods:\n                pipe.abort = function () {\n                    var args = [undefined, 'abort', 'abort'];\n                    if (!jqXHR) {\n                        if (slot) {\n                            slot.rejectWith(pipe, args);\n                        }\n                        return send(false, args);\n                    }\n                    return jqXHR.abort();\n                };\n                return this._enhancePromise(pipe);\n            }\n            return send();\n        },\n\n        _onAdd: function (e, data) {\n            var that = this,\n                result = true,\n                options = $.extend({}, this.options, data),\n                limit = options.limitMultiFileUploads,\n                paramName = this._getParamName(options),\n                paramNameSet,\n                paramNameSlice,\n                fileSet,\n                i;\n            if (!(options.singleFileUploads || limit) ||\n                    !this._isXHRUpload(options)) {\n                fileSet = [data.files];\n                paramNameSet = [paramName];\n            } else if (!options.singleFileUploads && limit) {\n                fileSet = [];\n                paramNameSet = [];\n                for (i = 0; i < data.files.length; i += limit) {\n                    fileSet.push(data.files.slice(i, i + limit));\n                    paramNameSlice = paramName.slice(i, i + limit);\n                    if (!paramNameSlice.length) {\n                        paramNameSlice = paramName;\n                    }\n                    paramNameSet.push(paramNameSlice);\n                }\n            } else {\n                paramNameSet = paramName;\n            }\n            data.originalFiles = data.files;\n            $.each(fileSet || data.files, function (index, element) {\n                var newData = $.extend({}, data);\n                newData.files = fileSet ? element : [element];\n                newData.paramName = paramNameSet[index];\n                newData.submit = function () {\n                    newData.jqXHR = this.jqXHR =\n                        (that._trigger('submit', e, this) !== false) &&\n                        that._onSend(e, this);\n                    return this.jqXHR;\n                };\n                return (result = that._trigger('add', e, newData));\n            });\n            return result;\n        },\n\n        _replaceFileInput: function (input) {\n            var inputClone = input.clone(true);\n            $('<form></form>').append(inputClone)[0].reset();\n            // Detaching allows to insert the fileInput on another form\n            // without loosing the file input value:\n            input.after(inputClone).detach();\n            // Avoid memory leaks with the detached file input:\n            $.cleanData(input.unbind('remove'));\n            // Replace the original file input element in the fileInput\n            // collection with the clone, which has been copied including\n            // event handlers:\n            this.options.fileInput = this.options.fileInput.map(function (i, el) {\n                if (el === input[0]) {\n                    return inputClone[0];\n                }\n                return el;\n            });\n            // If the widget has been initialized on the file input itself,\n            // override this.element with the file input clone:\n            if (input[0] === this.element[0]) {\n                this.element = inputClone;\n            }\n        },\n\n        _handleFileTreeEntry: function (entry, path) {\n            var that = this,\n                dfd = $.Deferred(),\n                errorHandler = function () {\n                    dfd.reject();\n                },\n                dirReader;\n            path = path || '';\n            if (entry.isFile) {\n                entry.file(function (file) {\n                    file.relativePath = path;\n                    dfd.resolve(file);\n                }, errorHandler);\n            } else if (entry.isDirectory) {\n                dirReader = entry.createReader();\n                dirReader.readEntries(function (entries) {\n                    that._handleFileTreeEntries(\n                        entries,\n                        path + entry.name + '/'\n                    ).done(function (files) {\n                        dfd.resolve(files);\n                    }).fail(errorHandler);\n                }, errorHandler);\n            } else {\n                errorHandler();\n            }\n            return dfd.promise();\n        },\n\n        _handleFileTreeEntries: function (entries, path) {\n            var that = this;\n            return $.when.apply(\n                $,\n                $.map(entries, function (entry) {\n                    return that._handleFileTreeEntry(entry, path);\n                })\n            ).pipe(function () {\n                return Array.prototype.concat.apply(\n                    [],\n                    arguments\n                );\n            });\n        },\n\n        _getDroppedFiles: function (dataTransfer) {\n            dataTransfer = dataTransfer || {};\n            var items = dataTransfer.items;\n            if (items && items.length && (items[0].webkitGetAsEntry ||\n                    items[0].getAsEntry)) {\n                return this._handleFileTreeEntries(\n                    $.map(items, function (item) {\n                        if (item.webkitGetAsEntry) {\n                            return item.webkitGetAsEntry();\n                        }\n                        return item.getAsEntry();\n                    })\n                );\n            }\n            return $.Deferred().resolve(\n                $.makeArray(dataTransfer.files)\n            ).promise();\n        },\n\n        _getFileInputFiles: function (fileInput) {\n            fileInput = $(fileInput);\n            var entries = fileInput.prop('webkitEntries') ||\n                    fileInput.prop('entries'),\n                files,\n                value;\n            if (entries && entries.length) {\n                return this._handleFileTreeEntries(entries);\n            }\n            files = $.makeArray(fileInput.prop('files'));\n            if (!files.length) {\n                value = fileInput.prop('value');\n                if (!value) {\n                    return $.Deferred().reject([]).promise();\n                }\n                // If the files property is not available, the browser does not\n                // support the File API and we add a pseudo File object with\n                // the input value as name with path information removed:\n                files = [{name: value.replace(/^.*\\\\/, '')}];\n            }\n            return $.Deferred().resolve(files).promise();\n        },\n\n        _onChange: function (e) {\n            var that = e.data.fileupload,\n                data = {\n                    fileInput: $(e.target),\n                    form: $(e.target.form)\n                };\n            that._getFileInputFiles(data.fileInput).always(function (files) {\n                data.files = files;\n                if (that.options.replaceFileInput) {\n                    that._replaceFileInput(data.fileInput);\n                }\n                if (that._trigger('change', e, data) !== false) {\n                    that._onAdd(e, data);\n                }\n            });\n        },\n\n        _onPaste: function (e) {\n            var that = e.data.fileupload,\n                cbd = e.originalEvent.clipboardData,\n                items = (cbd && cbd.items) || [],\n                data = {files: []};\n            $.each(items, function (index, item) {\n                var file = item.getAsFile && item.getAsFile();\n                if (file) {\n                    data.files.push(file);\n                }\n            });\n            if (that._trigger('paste', e, data) === false ||\n                    that._onAdd(e, data) === false) {\n                return false;\n            }\n        },\n\n        _onDrop: function (e) {\n            e.preventDefault();\n            var that = e.data.fileupload,\n                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,\n                data = {};\n            that._getDroppedFiles(dataTransfer).always(function (files) {\n                data.files = files;\n                if (that._trigger('drop', e, data) !== false) {\n                    that._onAdd(e, data);\n                }\n            });\n        },\n\n        _onDragOver: function (e) {\n            var that = e.data.fileupload,\n                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;\n            if (that._trigger('dragover', e) === false) {\n                return false;\n            }\n            if (dataTransfer) {\n                dataTransfer.dropEffect = 'copy';\n            }\n            e.preventDefault();\n        },\n\n        _initEventHandlers: function () {\n            var ns = this.options.namespace;\n            if (this._isXHRUpload(this.options)) {\n                this.options.dropZone\n                    .bind('dragover.' + ns, {fileupload: this}, this._onDragOver)\n                    .bind('drop.' + ns, {fileupload: this}, this._onDrop)\n                    .bind('paste.' + ns, {fileupload: this}, this._onPaste);\n            }\n            this.options.fileInput\n                .bind('change.' + ns, {fileupload: this}, this._onChange);\n        },\n\n        _destroyEventHandlers: function () {\n            var ns = this.options.namespace;\n            this.options.dropZone\n                .unbind('dragover.' + ns, this._onDragOver)\n                .unbind('drop.' + ns, this._onDrop)\n                .unbind('paste.' + ns, this._onPaste);\n            this.options.fileInput\n                .unbind('change.' + ns, this._onChange);\n        },\n\n        _setOption: function (key, value) {\n            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;\n            if (refresh) {\n                this._destroyEventHandlers();\n            }\n            $.Widget.prototype._setOption.call(this, key, value);\n            if (refresh) {\n                this._initSpecialOptions();\n                this._initEventHandlers();\n            }\n        },\n\n        _initSpecialOptions: function () {\n            var options = this.options;\n            if (options.fileInput === undefined) {\n                options.fileInput = this.element.is('input[type=\"file\"]') ?\n                        this.element : this.element.find('input[type=\"file\"]');\n            } else if (!(options.fileInput instanceof $)) {\n                options.fileInput = $(options.fileInput);\n            }\n            if (!(options.dropZone instanceof $)) {\n                options.dropZone = $(options.dropZone);\n            }\n        },\n\n        _create: function () {\n            var options = this.options;\n            // Initialize options set via HTML5 data-attributes:\n            $.extend(options, $(this.element[0].cloneNode(false)).data());\n            options.namespace = options.namespace || this.widgetName;\n            this._initSpecialOptions();\n            this._slots = [];\n            this._sequence = this._getXHRPromise(true);\n            this._sending = this._active = this._loaded = this._total = 0;\n            this._initEventHandlers();\n        },\n\n        destroy: function () {\n            this._destroyEventHandlers();\n            $.Widget.prototype.destroy.call(this);\n        },\n\n        enable: function () {\n            var wasDisabled = false;\n            if (this.options.disabled) {\n                wasDisabled = true;\n            }\n            $.Widget.prototype.enable.call(this);\n            if (wasDisabled) {\n                this._initEventHandlers();\n            }\n        },\n\n        disable: function () {\n            if (!this.options.disabled) {\n                this._destroyEventHandlers();\n            }\n            $.Widget.prototype.disable.call(this);\n        },\n\n        // This method is exposed to the widget API and allows adding files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files property and can contain additional options:\n        // .fileupload('add', {files: filesList});\n        add: function (data) {\n            var that = this;\n            if (!data || this.options.disabled) {\n                return;\n            }\n            if (data.fileInput && !data.files) {\n                this._getFileInputFiles(data.fileInput).always(function (files) {\n                    data.files = files;\n                    that._onAdd(null, data);\n                });\n            } else {\n                data.files = $.makeArray(data.files);\n                this._onAdd(null, data);\n            }\n        },\n\n        // This method is exposed to the widget API and allows sending files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files or fileInput property and can contain additional options:\n        // .fileupload('send', {files: filesList});\n        // The method returns a Promise object for the file upload call.\n        send: function (data) {\n            if (data && !this.options.disabled) {\n                if (data.fileInput && !data.files) {\n                    var that = this,\n                        dfd = $.Deferred(),\n                        promise = dfd.promise(),\n                        jqXHR,\n                        aborted;\n                    promise.abort = function () {\n                        aborted = true;\n                        if (jqXHR) {\n                            return jqXHR.abort();\n                        }\n                        dfd.reject(null, 'abort', 'abort');\n                        return promise;\n                    };\n                    this._getFileInputFiles(data.fileInput).always(\n                        function (files) {\n                            if (aborted) {\n                                return;\n                            }\n                            data.files = files;\n                            jqXHR = that._onSend(null, data).then(\n                                function (result, textStatus, jqXHR) {\n                                    dfd.resolve(result, textStatus, jqXHR);\n                                },\n                                function (jqXHR, textStatus, errorThrown) {\n                                    dfd.reject(jqXHR, textStatus, errorThrown);\n                                }\n                            );\n                        }\n                    );\n                    return this._enhancePromise(promise);\n                }\n                data.files = $.makeArray(data.files);\n                if (data.files.length) {\n                    return this._onSend(null, data);\n                }\n            }\n            return this._getXHRPromise(false, data && data.context);\n        }\n\n    });\n\n}));\n","fotorama/fotorama.js":"/*!\n * Fotorama 4.6.4 | http://fotorama.io/license/\n */\nfotoramaVersion = '4.6.4';\n(function (window, document, location, $, undefined) {\n    \"use strict\";\n    var _fotoramaClass = 'fotorama',\n        _fullscreenClass = 'fotorama__fullscreen',\n\n        wrapClass = _fotoramaClass + '__wrap',\n        wrapCss2Class = wrapClass + '--css2',\n        wrapCss3Class = wrapClass + '--css3',\n        wrapVideoClass = wrapClass + '--video',\n        wrapFadeClass = wrapClass + '--fade',\n        wrapSlideClass = wrapClass + '--slide',\n        wrapNoControlsClass = wrapClass + '--no-controls',\n        wrapNoShadowsClass = wrapClass + '--no-shadows',\n        wrapPanYClass = wrapClass + '--pan-y',\n        wrapRtlClass = wrapClass + '--rtl',\n        wrapOnlyActiveClass = wrapClass + '--only-active',\n        wrapNoCaptionsClass = wrapClass + '--no-captions',\n        wrapToggleArrowsClass = wrapClass + '--toggle-arrows',\n\n        stageClass = _fotoramaClass + '__stage',\n        stageFrameClass = stageClass + '__frame',\n        stageFrameVideoClass = stageFrameClass + '--video',\n        stageShaftClass = stageClass + '__shaft',\n\n        grabClass = _fotoramaClass + '__grab',\n        pointerClass = _fotoramaClass + '__pointer',\n\n        arrClass = _fotoramaClass + '__arr',\n        arrDisabledClass = arrClass + '--disabled',\n        arrPrevClass = arrClass + '--prev',\n        arrNextClass = arrClass + '--next',\n\n        navClass = _fotoramaClass + '__nav',\n        navWrapClass = navClass + '-wrap',\n        navShaftClass = navClass + '__shaft',\n        navShaftVerticalClass = navWrapClass + '--vertical',\n        navShaftListClass = navWrapClass + '--list',\n        navShafthorizontalClass = navWrapClass + '--horizontal',\n        navDotsClass = navClass + '--dots',\n        navThumbsClass = navClass + '--thumbs',\n        navFrameClass = navClass + '__frame',\n\n        fadeClass = _fotoramaClass + '__fade',\n        fadeFrontClass = fadeClass + '-front',\n        fadeRearClass = fadeClass + '-rear',\n\n        shadowClass = _fotoramaClass + '__shadow',\n        shadowsClass = shadowClass + 's',\n        shadowsLeftClass = shadowsClass + '--left',\n        shadowsRightClass = shadowsClass + '--right',\n        shadowsTopClass = shadowsClass + '--top',\n        shadowsBottomClass = shadowsClass + '--bottom',\n\n        activeClass = _fotoramaClass + '__active',\n        selectClass = _fotoramaClass + '__select',\n\n        hiddenClass = _fotoramaClass + '--hidden',\n\n        fullscreenClass = _fotoramaClass + '--fullscreen',\n        fullscreenIconClass = _fotoramaClass + '__fullscreen-icon',\n\n        errorClass = _fotoramaClass + '__error',\n        loadingClass = _fotoramaClass + '__loading',\n        loadedClass = _fotoramaClass + '__loaded',\n        loadedFullClass = loadedClass + '--full',\n        loadedImgClass = loadedClass + '--img',\n\n        grabbingClass = _fotoramaClass + '__grabbing',\n\n        imgClass = _fotoramaClass + '__img',\n        imgFullClass = imgClass + '--full',\n\n        thumbClass = _fotoramaClass + '__thumb',\n        thumbArrLeft = thumbClass + '__arr--left',\n        thumbArrRight = thumbClass + '__arr--right',\n        thumbBorderClass = thumbClass + '-border',\n\n        htmlClass = _fotoramaClass + '__html',\n\n        videoContainerClass = _fotoramaClass + '-video-container',\n        videoClass = _fotoramaClass + '__video',\n        videoPlayClass = videoClass + '-play',\n        videoCloseClass = videoClass + '-close',\n\n        spinnerClass = _fotoramaClass + '__spinner',\n\n        horizontalImageClass = _fotoramaClass + '_horizontal_ratio',\n        verticalImageClass = _fotoramaClass + '_vertical_ratio';\n    var JQUERY_VERSION = $ && $.fn.jquery.split('.');\n\n    if (!JQUERY_VERSION\n        || JQUERY_VERSION[0] < 1\n        || (JQUERY_VERSION[0] == 1 && JQUERY_VERSION[1] < 8)) {\n        throw 'Fotorama requires jQuery 1.8 or later and will not run without it.';\n    }\n\n    var _ = {};\n    /* Modernizr 2.8.3 (Custom Build) | MIT & BSD\n     * Build: http://modernizr.com/download/#-csstransforms3d-csstransitions-touch-prefixed\n     */\n\n    var Modernizr = (function (window, document, undefined) {\n        var version = '2.8.3',\n            Modernizr = {},\n\n\n            docElement = document.documentElement,\n\n            mod = 'modernizr',\n            modElem = document.createElement(mod),\n            mStyle = modElem.style,\n            inputElem,\n\n\n            toString = {}.toString,\n\n            prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),\n\n\n            omPrefixes = 'Webkit Moz O ms',\n\n            cssomPrefixes = omPrefixes.split(' '),\n\n            domPrefixes = omPrefixes.toLowerCase().split(' '),\n\n\n            tests = {},\n            inputs = {},\n            attrs = {},\n\n            classes = [],\n\n            slice = classes.slice,\n\n            featureName,\n\n\n            injectElementWithStyles = function (rule, callback, nodes, testnames) {\n\n                var style, ret, node, docOverflow,\n                    div = document.createElement('div'),\n                    body = document.body,\n                    fakeBody = body || document.createElement('body');\n\n                if (parseInt(nodes, 10)) {\n                    while (nodes--) {\n                        node = document.createElement('div');\n                        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);\n                        div.appendChild(node);\n                    }\n                }\n\n                style = ['&#173;', '<style id=\"s', mod, '\">', rule, '</style>'].join('');\n                div.id = mod;\n                (body ? div : fakeBody).innerHTML += style;\n                fakeBody.appendChild(div);\n                if (!body) {\n                    fakeBody.style.background = '';\n                    fakeBody.style.overflow = 'hidden';\n                    docOverflow = docElement.style.overflow;\n                    docElement.style.overflow = 'hidden';\n                    docElement.appendChild(fakeBody);\n                }\n\n                ret = callback(div, rule);\n                if (!body) {\n                    fakeBody.parentNode.removeChild(fakeBody);\n                    docElement.style.overflow = docOverflow;\n                } else {\n                    div.parentNode.removeChild(div);\n                }\n\n                return !!ret;\n\n            },\n            _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;\n\n        if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {\n            hasOwnProp = function (object, property) {\n                return _hasOwnProperty.call(object, property);\n            };\n        }\n        else {\n            hasOwnProp = function (object, property) {\n                return ((property in object) && is(object.constructor.prototype[property], 'undefined'));\n            };\n        }\n\n\n        if (!Function.prototype.bind) {\n            Function.prototype.bind = function bind(that) {\n\n                var target = this;\n\n                if (typeof target != \"function\") {\n                    throw new TypeError();\n                }\n\n                var args = slice.call(arguments, 1),\n                    bound = function () {\n\n                        if (this instanceof bound) {\n\n                            var F = function () {\n                            };\n                            F.prototype = target.prototype;\n                            var self = new F();\n\n                            var result = target.apply(\n                                self,\n                                args.concat(slice.call(arguments))\n                            );\n                            if (Object(result) === result) {\n                                return result;\n                            }\n                            return self;\n\n                        } else {\n\n                            return target.apply(\n                                that,\n                                args.concat(slice.call(arguments))\n                            );\n\n                        }\n\n                    };\n\n                return bound;\n            };\n        }\n\n        function setCss(str) {\n            mStyle.cssText = str;\n        }\n\n        function setCssAll(str1, str2) {\n            return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));\n        }\n\n        function is(obj, type) {\n            return typeof obj === type;\n        }\n\n        function contains(str, substr) {\n            return !!~('' + str).indexOf(substr);\n        }\n\n        function testProps(props, prefixed) {\n            for (var i in props) {\n                var prop = props[i];\n                if (!contains(prop, \"-\") && mStyle[prop] !== undefined) {\n                    return prefixed == 'pfx' ? prop : true;\n                }\n            }\n            return false;\n        }\n\n        function testDOMProps(props, obj, elem) {\n            for (var i in props) {\n                var item = obj[props[i]];\n                if (item !== undefined) {\n\n                    if (elem === false) return props[i];\n\n                    if (is(item, 'function')) {\n                        return item.bind(elem || obj);\n                    }\n\n                    return item;\n                }\n            }\n            return false;\n        }\n\n        function testPropsAll(prop, prefixed, elem) {\n\n            var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n                props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');\n\n            if (is(prefixed, \"string\") || is(prefixed, \"undefined\")) {\n                return testProps(props, prefixed);\n\n            } else {\n                props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');\n                return testDOMProps(props, prefixed, elem);\n            }\n        }\n\n        tests['touch'] = function () {\n            var bool;\n\n            if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {\n                bool = true;\n            } else {\n                injectElementWithStyles(['@media (', prefixes.join('touch-enabled),('), mod, ')', '{#modernizr{top:9px;position:absolute}}'].join(''), function (node) {\n                    bool = node.offsetTop === 9;\n                });\n            }\n\n            return bool;\n        };\n        tests['csstransforms3d'] = function () {\n\n            var ret = !!testPropsAll('perspective');\n\n            if (ret && 'webkitPerspective' in docElement.style) {\n\n                injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function (node, rule) {\n                    ret = node.offsetLeft === 9 && node.offsetHeight === 3;\n                });\n            }\n            return ret;\n        };\n\n\n        tests['csstransitions'] = function () {\n            return testPropsAll('transition');\n        };\n\n\n        for (var feature in tests) {\n            if (hasOwnProp(tests, feature)) {\n                featureName = feature.toLowerCase();\n                Modernizr[featureName] = tests[feature]();\n\n                classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);\n            }\n        }\n\n\n        Modernizr.addTest = function (feature, test) {\n            if (typeof feature == 'object') {\n                for (var key in feature) {\n                    if (hasOwnProp(feature, key)) {\n                        Modernizr.addTest(key, feature[key]);\n                    }\n                }\n            } else {\n\n                feature = feature.toLowerCase();\n\n                if (Modernizr[feature] !== undefined) {\n                    return Modernizr;\n                }\n\n                test = typeof test == 'function' ? test() : test;\n\n                if (typeof enableClasses !== \"undefined\" && enableClasses) {\n                    docElement.className += ' ' + (test ? '' : 'no-') + feature;\n                }\n                Modernizr[feature] = test;\n\n            }\n\n            return Modernizr;\n        };\n\n\n        setCss('');\n        modElem = inputElem = null;\n\n\n        Modernizr._version = version;\n\n        Modernizr._prefixes = prefixes;\n        Modernizr._domPrefixes = domPrefixes;\n        Modernizr._cssomPrefixes = cssomPrefixes;\n\n\n        Modernizr.testProp = function (prop) {\n            return testProps([prop]);\n        };\n\n        Modernizr.testAllProps = testPropsAll;\n        Modernizr.testStyles = injectElementWithStyles;\n        Modernizr.prefixed = function (prop, obj, elem) {\n            if (!obj) {\n                return testPropsAll(prop, 'pfx');\n            } else {\n                return testPropsAll(prop, obj, elem);\n            }\n        };\n        return Modernizr;\n    })(window, document);\n\n    var fullScreenApi = {\n            ok: false,\n            is: function () {\n                return false;\n            },\n            request: function () {\n            },\n            cancel: function () {\n            },\n            event: '',\n            prefix: ''\n        },\n        browserPrefixes = 'webkit moz o ms khtml'.split(' ');\n\n// check for native support\n    if (typeof document.cancelFullScreen != 'undefined') {\n        fullScreenApi.ok = true;\n    } else {\n        // check for fullscreen support by vendor prefix\n        for (var i = 0, il = browserPrefixes.length; i < il; i++) {\n            fullScreenApi.prefix = browserPrefixes[i];\n            if (typeof document[fullScreenApi.prefix + 'CancelFullScreen'] != 'undefined') {\n                fullScreenApi.ok = true;\n                break;\n            }\n        }\n    }\n\n// update methods to do something useful\n    if (fullScreenApi.ok) {\n        fullScreenApi.event = fullScreenApi.prefix + 'fullscreenchange';\n        fullScreenApi.is = function () {\n            switch (this.prefix) {\n                case '':\n                    return document.fullScreen;\n                case 'webkit':\n                    return document.webkitIsFullScreen;\n                default:\n                    return document[this.prefix + 'FullScreen'];\n            }\n        };\n        fullScreenApi.request = function (el) {\n            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();\n        };\n        fullScreenApi.cancel = function (el) {\n            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();\n        };\n    }\n//fgnass.github.com/spin.js#v1.3.2\n\n    /**\n     * Copyright (c) 2011-2013 Felix Gnass\n     * Licensed under the MIT license\n     */\n\n    var Spinner,\n        spinnerDefaults = {\n            lines: 12, // The number of lines to draw\n            length: 5, // The length of each line\n            width: 2, // The line thickness\n            radius: 7, // The radius of the inner circle\n            corners: 1, // Corner roundness (0..1)\n            rotate: 15, // The rotation offset\n            color: 'rgba(128, 128, 128, .75)',\n            hwaccel: true\n        },\n        spinnerOverride = {\n            top: 'auto',\n            left: 'auto',\n            className: ''\n        };\n\n    (function (root, factory) {\n\n        /* CommonJS */\n        //if (typeof exports == 'object')  module.exports = factory()\n\n        /* AMD module */\n        //else if (typeof define == 'function' && define.amd) define(factory)\n\n        /* Browser global */\n        //else root.Spinner = factory()\n\n        Spinner = factory();\n    }\n    (this, function () {\n        \"use strict\";\n\n        var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */\n            , animations = {} /* Animation rules keyed by their name */\n            , useCssAnimations\n        /* Whether to use CSS animations or setTimeout */\n\n        /**\n         * Utility function to create elements. If no tag name is given,\n         * a DIV is created. Optionally properties can be passed.\n         */\n        function createEl(tag, prop) {\n            var el = document.createElement(tag || 'div')\n                , n\n\n            for (n in prop) el[n] = prop[n]\n            return el\n        }\n\n        /**\n         * Appends children and returns the parent.\n         */\n        function ins(parent /* child1, child2, ...*/) {\n            for (var i = 1, n = arguments.length; i < n; i++)\n                parent.appendChild(arguments[i])\n\n            return parent\n        }\n\n        /**\n         * Insert a new stylesheet to hold the @keyframe or VML rules.\n         */\n        var sheet = (function () {\n            var el = createEl('style', {type: 'text/css'})\n            ins(document.getElementsByTagName('head')[0], el)\n            return el.sheet || el.styleSheet\n        }())\n\n        /**\n         * Creates an opacity keyframe animation rule and returns its name.\n         * Since most mobile Webkits have timing issues with animation-delay,\n         * we create separate rules for each line/segment.\n         */\n        function addAnimation(alpha, trail, i, lines) {\n            var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-')\n                , start = 0.01 + i / lines * 100\n                , z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha)\n                , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()\n                , pre = prefix && '-' + prefix + '-' || ''\n\n            if (!animations[name]) {\n                sheet.insertRule(\n                    '@' + pre + 'keyframes ' + name + '{' +\n                    '0%{opacity:' + z + '}' +\n                    start + '%{opacity:' + alpha + '}' +\n                    (start + 0.01) + '%{opacity:1}' +\n                    (start + trail) % 100 + '%{opacity:' + alpha + '}' +\n                    '100%{opacity:' + z + '}' +\n                    '}', sheet.cssRules.length)\n\n                animations[name] = 1\n            }\n\n            return name\n        }\n\n        /**\n         * Tries various vendor prefixes and returns the first supported property.\n         */\n        function vendor(el, prop) {\n            var s = el.style\n                , pp\n                , i\n\n            prop = prop.charAt(0).toUpperCase() + prop.slice(1)\n            for (i = 0; i < prefixes.length; i++) {\n                pp = prefixes[i] + prop\n                if (s[pp] !== undefined) return pp\n            }\n            if (s[prop] !== undefined) return prop\n        }\n\n        /**\n         * Sets multiple style properties at once.\n         */\n        function css(el, prop) {\n            for (var n in prop)\n                el.style[vendor(el, n) || n] = prop[n]\n\n            return el\n        }\n\n        /**\n         * Fills in default values.\n         */\n        function merge(obj) {\n            for (var i = 1; i < arguments.length; i++) {\n                var def = arguments[i]\n                for (var n in def)\n                    if (obj[n] === undefined) obj[n] = def[n]\n            }\n            return obj\n        }\n\n        /**\n         * Returns the absolute page-offset of the given element.\n         */\n        function pos(el) {\n            var o = {x: el.offsetLeft, y: el.offsetTop}\n            while ((el = el.offsetParent))\n                o.x += el.offsetLeft, o.y += el.offsetTop\n\n            return o\n        }\n\n        /**\n         * Returns the line color from the given string or array.\n         */\n        function getColor(color, idx) {\n            return typeof color == 'string' ? color : color[idx % color.length]\n        }\n\n        // Built-in defaults\n\n        var defaults = {\n            lines: 12,            // The number of lines to draw\n            length: 7,            // The length of each line\n            width: 5,             // The line thickness\n            radius: 10,           // The radius of the inner circle\n            rotate: 0,            // Rotation offset\n            corners: 1,           // Roundness (0..1)\n            color: '#000',        // #rgb or #rrggbb\n            direction: 1,         // 1: clockwise, -1: counterclockwise\n            speed: 1,             // Rounds per second\n            trail: 100,           // Afterglow percentage\n            opacity: 1 / 4,         // Opacity of the lines\n            fps: 20,              // Frames per second when using setTimeout()\n            zIndex: 2e9,          // Use a high z-index by default\n            className: 'spinner', // CSS class to assign to the element\n            top: 'auto',          // center vertically\n            left: 'auto',         // center horizontally\n            position: 'relative'  // element position\n        }\n\n        /** The constructor */\n        function Spinner(o) {\n            if (typeof this == 'undefined') return new Spinner(o)\n            this.opts = merge(o || {}, Spinner.defaults, defaults)\n        }\n\n        // Global defaults that override the built-ins:\n        Spinner.defaults = {}\n\n        merge(Spinner.prototype, {\n\n            /**\n             * Adds the spinner to the given target element. If this instance is already\n             * spinning, it is automatically removed from its previous target b calling\n             * stop() internally.\n             */\n            spin: function (target) {\n                this.stop()\n\n                var self = this\n                    , o = self.opts\n                    , el = self.el = css(createEl(0, {className: o.className}), {\n                        position: o.position,\n                        width: 0,\n                        zIndex: o.zIndex\n                    })\n                    , mid = o.radius + o.length + o.width\n                    , ep // element position\n                    , tp // target position\n\n                if (target) {\n                    target.insertBefore(el, target.firstChild || null)\n                    tp = pos(target)\n                    ep = pos(el)\n                    css(el, {\n                        left: (o.left == 'auto' ? tp.x - ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',\n                        top: (o.top == 'auto' ? tp.y - ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid) + 'px'\n                    })\n                }\n\n                el.setAttribute('role', 'progressbar')\n                self.lines(el, self.opts)\n\n                if (!useCssAnimations) {\n                    // No CSS animation support, use setTimeout() instead\n                    var i = 0\n                        , start = (o.lines - 1) * (1 - o.direction) / 2\n                        , alpha\n                        , fps = o.fps\n                        , f = fps / o.speed\n                        , ostep = (1 - o.opacity) / (f * o.trail / 100)\n                        , astep = f / o.lines\n\n                        ;\n                    (function anim() {\n                        i++;\n                        for (var j = 0; j < o.lines; j++) {\n                            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)\n\n                            self.opacity(el, j * o.direction + start, alpha, o)\n                        }\n                        self.timeout = self.el && setTimeout(anim, ~~(1000 / fps))\n                    })()\n                }\n                return self\n            },\n\n            /**\n             * Stops and removes the Spinner.\n             */\n            stop: function () {\n                var el = this.el\n                if (el) {\n                    clearTimeout(this.timeout)\n                    if (el.parentNode) el.parentNode.removeChild(el)\n                    this.el = undefined\n                }\n                return this\n            },\n\n            /**\n             * Internal method that draws the individual lines. Will be overwritten\n             * in VML fallback mode below.\n             */\n            lines: function (el, o) {\n                var i = 0\n                    , start = (o.lines - 1) * (1 - o.direction) / 2\n                    , seg\n\n                function fill(color, shadow) {\n                    return css(createEl(), {\n                        position: 'absolute',\n                        width: (o.length + o.width) + 'px',\n                        height: o.width + 'px',\n                        background: color,\n                        boxShadow: shadow,\n                        transformOrigin: 'left',\n                        transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.radius + 'px' + ',0)',\n                        borderRadius: (o.corners * o.width >> 1) + 'px'\n                    })\n                }\n\n                for (; i < o.lines; i++) {\n                    seg = css(createEl(), {\n                        position: 'absolute',\n                        top: 1 + ~(o.width / 2) + 'px',\n                        transform: o.hwaccel ? 'translate3d(0,0,0)' : '',\n                        opacity: o.opacity,\n                        animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'\n                    })\n\n                    if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2 + 'px'}))\n                    ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))\n                }\n                return el\n            },\n\n            /**\n             * Internal method that adjusts the opacity of a single line.\n             * Will be overwritten in VML fallback mode below.\n             */\n            opacity: function (el, i, val) {\n                if (i < el.childNodes.length) el.childNodes[i].style.opacity = val\n            }\n\n        })\n\n\n        function initVML() {\n\n            /* Utility function to create a VML tag */\n            function vml(tag, attr) {\n                return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr)\n            }\n\n            // No CSS transforms but VML support, add a CSS rule for VML elements:\n            sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')\n\n            Spinner.prototype.lines = function (el, o) {\n                var r = o.length + o.width\n                    , s = 2 * r\n\n                function grp() {\n                    return css(\n                        vml('group', {\n                            coordsize: s + ' ' + s,\n                            coordorigin: -r + ' ' + -r\n                        }),\n                        {width: s, height: s}\n                    )\n                }\n\n                var margin = -(o.width + o.length) * 2 + 'px'\n                    , g = css(grp(), {position: 'absolute', top: margin, left: margin})\n                    , i\n\n                function seg(i, dx, filter) {\n                    ins(g,\n                        ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),\n                            ins(css(vml('roundrect', {arcsize: o.corners}), {\n                                    width: r,\n                                    height: o.width,\n                                    left: o.radius,\n                                    top: -o.width >> 1,\n                                    filter: filter\n                                }),\n                                vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),\n                                vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change\n                            )\n                        )\n                    )\n                }\n\n                if (o.shadow)\n                    for (i = 1; i <= o.lines; i++)\n                        seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')\n\n                for (i = 1; i <= o.lines; i++) seg(i)\n                return ins(el, g)\n            }\n\n            Spinner.prototype.opacity = function (el, i, val, o) {\n                var c = el.firstChild\n                o = o.shadow && o.lines || 0\n                if (c && i + o < c.childNodes.length) {\n                    c = c.childNodes[i + o];\n                    c = c && c.firstChild;\n                    c = c && c.firstChild\n                    if (c) c.opacity = val\n                }\n            }\n        }\n\n        var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})\n\n        if (!vendor(probe, 'transform') && probe.adj) initVML()\n        else useCssAnimations = vendor(probe, 'animation')\n\n        return Spinner\n\n    }));\n\n    /* Bez v1.0.10-g5ae0136\n     * http://github.com/rdallasgray/bez\n     *\n     * A plugin to convert CSS3 cubic-bezier co-ordinates to jQuery-compatible easing functions\n     *\n     * With thanks to Nikolay Nemshilov for clarification on the cubic-bezier maths\n     * See http://st-on-it.blogspot.com/2011/05/calculating-cubic-bezier-function.html\n     *\n     * Copyright 2011 Robert Dallas Gray. All rights reserved.\n     * Provided under the FreeBSD license: https://github.com/rdallasgray/bez/blob/master/LICENSE.txt\n     */\n    function bez(coOrdArray) {\n        var encodedFuncName = \"bez_\" + $.makeArray(arguments).join(\"_\").replace(\".\", \"p\");\n        if (typeof $['easing'][encodedFuncName] !== \"function\") {\n            var polyBez = function (p1, p2) {\n                var A = [null, null],\n                    B = [null, null],\n                    C = [null, null],\n                    bezCoOrd = function (t, ax) {\n                        C[ax] = 3 * p1[ax];\n                        B[ax] = 3 * (p2[ax] - p1[ax]) - C[ax];\n                        A[ax] = 1 - C[ax] - B[ax];\n                        return t * (C[ax] + t * (B[ax] + t * A[ax]));\n                    },\n                    xDeriv = function (t) {\n                        return C[0] + t * (2 * B[0] + 3 * A[0] * t);\n                    },\n                    xForT = function (t) {\n                        var x = t, i = 0, z;\n                        while (++i < 14) {\n                            z = bezCoOrd(x, 0) - t;\n                            if (Math.abs(z) < 1e-3) break;\n                            x -= z / xDeriv(x);\n                        }\n                        return x;\n                    };\n                return function (t) {\n                    return bezCoOrd(xForT(t), 1);\n                }\n            };\n            $['easing'][encodedFuncName] = function (x, t, b, c, d) {\n                return c * polyBez([coOrdArray[0], coOrdArray[1]], [coOrdArray[2], coOrdArray[3]])(t / d) + b;\n            }\n        }\n        return encodedFuncName;\n    }\n\n    var $WINDOW = $(window),\n        $DOCUMENT = $(document),\n        $HTML,\n        $BODY,\n\n        QUIRKS_FORCE = location.hash.replace('#', '') === 'quirks',\n        TRANSFORMS3D = Modernizr.csstransforms3d,\n        CSS3 = TRANSFORMS3D && !QUIRKS_FORCE,\n        COMPAT = TRANSFORMS3D || document.compatMode === 'CSS1Compat',\n        FULLSCREEN = fullScreenApi.ok,\n\n        MOBILE = navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i),\n        SLOW = !CSS3 || MOBILE,\n\n        MS_POINTER = navigator.msPointerEnabled,\n\n        WHEEL = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\",\n\n        TOUCH_TIMEOUT = 250,\n        TRANSITION_DURATION = 300,\n\n        SCROLL_LOCK_TIMEOUT = 1400,\n\n        AUTOPLAY_INTERVAL = 5000,\n        MARGIN = 2,\n        THUMB_SIZE = 64,\n\n        WIDTH = 500,\n        HEIGHT = 333,\n\n        STAGE_FRAME_KEY = '$stageFrame',\n        NAV_DOT_FRAME_KEY = '$navDotFrame',\n        NAV_THUMB_FRAME_KEY = '$navThumbFrame',\n\n        AUTO = 'auto',\n\n        BEZIER = bez([.1, 0, .25, 1]),\n\n        MAX_WIDTH = 1200,\n\n        /**\n         * Number of thumbnails in slide. Calculated only on setOptions and resize.\n         * @type {number}\n         */\n        thumbsPerSlide = 1,\n\n        OPTIONS = {\n\n            /**\n             * Set width for gallery.\n             * Default value - width of first image\n             * Number - set value in px\n             * String - set value in quotes\n             *\n             */\n            width: null,\n\n            /**\n             * Set min-width for gallery\n             *\n             */\n            minwidth: null,\n\n            /**\n             * Set max-width for gallery\n             *\n             */\n            maxwidth: '100%',\n\n            /**\n             * Set height for gallery\n             * Default value - height of first image\n             * Number - set value in px\n             * String - set value in quotes\n             *\n             */\n            height: null,\n\n            /**\n             * Set min-height for gallery\n             *\n             */\n            minheight: null,\n\n            /**\n             * Set max-height for gallery\n             *\n             */\n            maxheight: null,\n\n            /**\n             * Set proportion ratio for gallery depends of image\n             *\n             */\n            ratio: null, // '16/9' || 500/333 || 1.5\n\n            margin: MARGIN,\n\n            nav: 'dots', // 'thumbs' || false\n            navposition: 'bottom', // 'top'\n            navwidth: null,\n            thumbwidth: THUMB_SIZE,\n            thumbheight: THUMB_SIZE,\n            thumbmargin: MARGIN,\n            thumbborderwidth: MARGIN,\n\n            allowfullscreen: false, // true || 'native'\n\n            transition: 'slide', // 'crossfade' || 'dissolve'\n            clicktransition: null,\n            transitionduration: TRANSITION_DURATION,\n\n            captions: true,\n\n            startindex: 0,\n\n            loop: false,\n\n            autoplay: false,\n            stopautoplayontouch: true,\n\n            keyboard: false,\n\n            arrows: true,\n            click: true,\n            swipe: false,\n            trackpad: false,\n\n            shuffle: false,\n\n            direction: 'ltr', // 'rtl'\n\n            shadows: true,\n            spinner: null,\n            showcaption: true,\n\n            /**\n             * Set type of thumbnail navigation\n             */\n            navdir: 'horizontal',\n\n            /**\n             * Set configuration to show or hide arrows in thumb navigation\n             */\n            navarrows: true,\n\n            /**\n             * Set type of navigation. Can be thumbs or slides\n             */\n            navtype: 'thumbs'\n\n        },\n\n        KEYBOARD_OPTIONS = {\n            left: true,\n            right: true,\n            down: false,\n            up: false,\n            space: false,\n            home: false,\n            end: false\n        };\n\n    function noop() {\n    }\n\n    function minMaxLimit(value, min, max) {\n        return Math.max(isNaN(min) ? -Infinity : min, Math.min(isNaN(max) ? Infinity : max, value));\n    }\n\n    function readTransform(css, dir) {\n        return css.match(/ma/) && css.match(/-?\\d+(?!d)/g)[css.match(/3d/) ?\n                (dir === 'vertical' ? 13 : 12) : (dir === 'vertical' ? 5 : 4)\n                ]\n    }\n\n    function readPosition($el, dir) {\n        if (CSS3) {\n            return +readTransform($el.css('transform'), dir);\n        } else {\n            return +$el.css(dir === 'vertical' ? 'top' : 'left').replace('px', '');\n        }\n    }\n\n    function getTranslate(pos, direction) {\n        var obj = {};\n\n        if (CSS3) {\n\n            switch (direction) {\n                case 'vertical':\n                    obj.transform = 'translate3d(0, ' + (pos) + 'px,0)';\n                    break;\n                case 'list':\n                    break;\n                default :\n                    obj.transform = 'translate3d(' + (pos) + 'px,0,0)';\n                    break;\n            }\n        } else {\n            direction === 'vertical' ?\n                obj.top = pos :\n                obj.left = pos;\n        }\n        return obj;\n    }\n\n    function getDuration(time) {\n        return {'transition-duration': time + 'ms'};\n    }\n\n    function unlessNaN(value, alternative) {\n        return isNaN(value) ? alternative : value;\n    }\n\n    function numberFromMeasure(value, measure) {\n        return unlessNaN(+String(value).replace(measure || 'px', ''));\n    }\n\n    function numberFromPercent(value) {\n        return /%$/.test(value) ? numberFromMeasure(value, '%') : undefined;\n    }\n\n    function numberFromWhatever(value, whole) {\n        return unlessNaN(numberFromPercent(value) / 100 * whole, numberFromMeasure(value));\n    }\n\n    function measureIsValid(value) {\n        return (!isNaN(numberFromMeasure(value)) || !isNaN(numberFromMeasure(value, '%'))) && value;\n    }\n\n    function getPosByIndex(index, side, margin, baseIndex) {\n\n        return (index - (baseIndex || 0)) * (side + (margin || 0));\n    }\n\n    function getIndexByPos(pos, side, margin, baseIndex) {\n        return -Math.round(pos / (side + (margin || 0)) - (baseIndex || 0));\n    }\n\n    function bindTransitionEnd($el) {\n        var elData = $el.data();\n\n        if (elData.tEnd) return;\n\n        var el = $el[0],\n            transitionEndEvent = {\n                WebkitTransition: 'webkitTransitionEnd',\n                MozTransition: 'transitionend',\n                OTransition: 'oTransitionEnd otransitionend',\n                msTransition: 'MSTransitionEnd',\n                transition: 'transitionend'\n            };\n        addEvent(el, transitionEndEvent[Modernizr.prefixed('transition')], function (e) {\n            elData.tProp && e.propertyName.match(elData.tProp) && elData.onEndFn();\n        });\n        elData.tEnd = true;\n    }\n\n    function afterTransition($el, property, fn, time) {\n        var ok,\n            elData = $el.data();\n\n        if (elData) {\n            elData.onEndFn = function () {\n                if (ok) return;\n                ok = true;\n                clearTimeout(elData.tT);\n                fn();\n            };\n            elData.tProp = property;\n\n            // Passive call, just in case of fail of native transition-end event\n            clearTimeout(elData.tT);\n            elData.tT = setTimeout(function () {\n                elData.onEndFn();\n            }, time * 1.5);\n\n            bindTransitionEnd($el);\n        }\n    }\n\n\n    function stop($el, pos/*, _001*/) {\n        var dir = $el.navdir || 'horizontal';\n        if ($el.length) {\n            var elData = $el.data();\n            if (CSS3) {\n                $el.css(getDuration(0));\n                elData.onEndFn = noop;\n                clearTimeout(elData.tT);\n            } else {\n                $el.stop();\n            }\n            var lockedPos = getNumber(pos, function () {\n                return readPosition($el, dir);\n            });\n\n            $el.css(getTranslate(lockedPos, dir/*, _001*/));//.width(); // `.width()` for reflow\n            return lockedPos;\n        }\n    }\n\n    function getNumber() {\n        var number;\n        for (var _i = 0, _l = arguments.length; _i < _l; _i++) {\n            number = _i ? arguments[_i]() : arguments[_i];\n            if (typeof number === 'number') {\n                break;\n            }\n        }\n\n        return number;\n    }\n\n    function edgeResistance(pos, edge) {\n        return Math.round(pos + ((edge - pos) / 1.5));\n    }\n\n    function getProtocol() {\n        getProtocol.p = getProtocol.p || (location.protocol === 'https:' ? 'https://' : 'http://');\n        return getProtocol.p;\n    }\n\n    function parseHref(href) {\n        var a = document.createElement('a');\n        a.href = href;\n        return a;\n    }\n\n    function findVideoId(href, forceVideo) {\n        if (typeof href !== 'string') return href;\n        href = parseHref(href);\n\n        var id,\n            type;\n\n        if (href.host.match(/youtube\\.com/) && href.search) {\n            //.log();\n            id = href.search.split('v=')[1];\n            if (id) {\n                var ampersandPosition = id.indexOf('&');\n                if (ampersandPosition !== -1) {\n                    id = id.substring(0, ampersandPosition);\n                }\n                type = 'youtube';\n            }\n        } else if (href.host.match(/youtube\\.com|youtu\\.be/)) {\n            id = href.pathname.replace(/^\\/(embed\\/|v\\/)?/, '').replace(/\\/.*/, '');\n            type = 'youtube';\n        } else if (href.host.match(/vimeo\\.com/)) {\n            type = 'vimeo';\n            id = href.pathname.replace(/^\\/(video\\/)?/, '').replace(/\\/.*/, '');\n        }\n\n        if ((!id || !type) && forceVideo) {\n            id = href.href;\n            type = 'custom';\n        }\n\n        return id ? {id: id, type: type, s: href.search.replace(/^\\?/, ''), p: getProtocol()} : false;\n    }\n\n    function getVideoThumbs(dataFrame, data, fotorama) {\n        var img, thumb, video = dataFrame.video;\n        if (video.type === 'youtube') {\n            thumb = getProtocol() + 'img.youtube.com/vi/' + video.id + '/default.jpg';\n            img = thumb.replace(/\\/default.jpg$/, '/hqdefault.jpg');\n            dataFrame.thumbsReady = true;\n        } else if (video.type === 'vimeo') {\n            $.ajax({\n                url: getProtocol() + 'vimeo.com/api/v2/video/' + video.id + '.json',\n                dataType: 'jsonp',\n                success: function (json) {\n                    dataFrame.thumbsReady = true;\n                    updateData(data, {\n                        img: json[0].thumbnail_large,\n                        thumb: json[0].thumbnail_small\n                    }, dataFrame.i, fotorama);\n                }\n            });\n        } else {\n            dataFrame.thumbsReady = true;\n        }\n\n        return {\n            img: img,\n            thumb: thumb\n        }\n    }\n\n    function updateData(data, _dataFrame, i, fotorama) {\n        for (var _i = 0, _l = data.length; _i < _l; _i++) {\n            var dataFrame = data[_i];\n\n            if (dataFrame.i === i && dataFrame.thumbsReady) {\n                var clear = {videoReady: true};\n                clear[STAGE_FRAME_KEY] = clear[NAV_THUMB_FRAME_KEY] = clear[NAV_DOT_FRAME_KEY] = false;\n\n                fotorama.splice(_i, 1, $.extend(\n                    {},\n                    dataFrame,\n                    clear,\n                    _dataFrame\n                ));\n\n                break;\n            }\n        }\n    }\n\n    function getDataFromHtml($el) {\n        var data = [];\n\n        function getDataFromImg($img, imgData, checkVideo) {\n            var $child = $img.children('img').eq(0),\n                _imgHref = $img.attr('href'),\n                _imgSrc = $img.attr('src'),\n                _thumbSrc = $child.attr('src'),\n                _video = imgData.video,\n                video = checkVideo ? findVideoId(_imgHref, _video === true) : false;\n\n            if (video) {\n                _imgHref = false;\n            } else {\n                video = _video;\n            }\n\n            getDimensions($img, $child, $.extend(imgData, {\n                video: video,\n                img: imgData.img || _imgHref || _imgSrc || _thumbSrc,\n                thumb: imgData.thumb || _thumbSrc || _imgSrc || _imgHref\n            }));\n        }\n\n        function getDimensions($img, $child, imgData) {\n            var separateThumbFLAG = imgData.thumb && imgData.img !== imgData.thumb,\n                width = numberFromMeasure(imgData.width || $img.attr('width')),\n                height = numberFromMeasure(imgData.height || $img.attr('height'));\n\n            $.extend(imgData, {\n                width: width,\n                height: height,\n                thumbratio: getRatio(imgData.thumbratio || (numberFromMeasure(imgData.thumbwidth || ($child && $child.attr('width')) || separateThumbFLAG || width) / numberFromMeasure(imgData.thumbheight || ($child && $child.attr('height')) || separateThumbFLAG || height)))\n            });\n        }\n\n        $el.children().each(function () {\n            var $this = $(this),\n                dataFrame = optionsToLowerCase($.extend($this.data(), {id: $this.attr('id')}));\n            if ($this.is('a, img')) {\n                getDataFromImg($this, dataFrame, true);\n            } else if (!$this.is(':empty')) {\n                getDimensions($this, null, $.extend(dataFrame, {\n                    html: this,\n                    _html: $this.html() // Because of IE\n                }));\n            } else return;\n\n            data.push(dataFrame);\n        });\n\n        return data;\n    }\n\n    function isHidden(el) {\n        return el.offsetWidth === 0 && el.offsetHeight === 0;\n    }\n\n    function isDetached(el) {\n        return !$.contains(document.documentElement, el);\n    }\n\n    function waitFor(test, fn, timeout, i) {\n        if (!waitFor.i) {\n            waitFor.i = 1;\n            waitFor.ii = [true];\n        }\n\n        i = i || waitFor.i;\n\n        if (typeof waitFor.ii[i] === 'undefined') {\n            waitFor.ii[i] = true;\n        }\n\n        if (test()) {\n            fn();\n        } else {\n            waitFor.ii[i] && setTimeout(function () {\n                waitFor.ii[i] && waitFor(test, fn, timeout, i);\n            }, timeout || 100);\n        }\n\n        return waitFor.i++;\n    }\n\n    waitFor.stop = function (i) {\n        waitFor.ii[i] = false;\n    };\n\n    function fit($el, measuresToFit) {\n        var elData = $el.data(),\n            measures = elData.measures;\n\n        if (measures && (!elData.l ||\n            elData.l.W !== measures.width ||\n            elData.l.H !== measures.height ||\n            elData.l.r !== measures.ratio ||\n            elData.l.w !== measuresToFit.w ||\n            elData.l.h !== measuresToFit.h)) {\n\n            var height = minMaxLimit(measuresToFit.h, 0, measures.height),\n                width = height * measures.ratio;\n\n            UTIL.setRatio($el, width, height);\n\n            elData.l = {\n                W: measures.width,\n                H: measures.height,\n                r: measures.ratio,\n                w: measuresToFit.w,\n                h: measuresToFit.h\n            };\n        }\n\n        return true;\n    }\n\n    function setStyle($el, style) {\n        var el = $el[0];\n        if (el.styleSheet) {\n            el.styleSheet.cssText = style;\n        } else {\n            $el.html(style);\n        }\n    }\n\n    function findShadowEdge(pos, min, max, dir) {\n        return min === max ? false :\n            dir === 'vertical' ?\n                (pos <= min ? 'top' : pos >= max ? 'bottom' : 'top bottom') :\n                (pos <= min ? 'left' : pos >= max ? 'right' : 'left right');\n    }\n\n    function smartClick($el, fn, _options) {\n        _options = _options || {};\n\n        $el.each(function () {\n            var $this = $(this),\n                thisData = $this.data(),\n                startEvent;\n\n            if (thisData.clickOn) return;\n\n            thisData.clickOn = true;\n\n            $.extend(touch($this, {\n                onStart: function (e) {\n                    startEvent = e;\n                    (_options.onStart || noop).call(this, e);\n                },\n                onMove: _options.onMove || noop,\n                onTouchEnd: _options.onTouchEnd || noop,\n                onEnd: function (result) {\n                    if (result.moved) return;\n                    fn.call(this, startEvent);\n                }\n            }), {noMove: true});\n        });\n    }\n\n    function div(classes, child) {\n        return '<div class=\"' + classes + '\">' + (child || '') + '</div>';\n    }\n\n\n    /**\n     * Function transforming into valid classname\n     * @param className - name of the class\n     * @returns {string} - dom format of class name\n     */\n    function cls(className) {\n        return \".\" + className;\n    }\n\n    /**\n     *\n     * @param {json-object} videoItem Parsed object from data.video item or href from link a in input dates\n     * @returns {string} DOM view of video iframe\n     */\n    function createVideoFrame(videoItem) {\n        var frame = '<iframe src=\"' + videoItem.p + videoItem.type + '.com/embed/' + videoItem.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n        return frame;\n    }\n\n// Fisher\u00e2\u0080\u0093Yates Shuffle\n// http://bost.ocks.org/mike/shuffle/\n    function shuffle(array) {\n        // While there remain elements to shuffle\n        var l = array.length;\n        while (l) {\n            // Pick a remaining element\n            var i = Math.floor(Math.random() * l--);\n\n            // And swap it with the current element\n            var t = array[l];\n            array[l] = array[i];\n            array[i] = t;\n        }\n\n        return array;\n    }\n\n    function clone(array) {\n        return Object.prototype.toString.call(array) == '[object Array]'\n            && $.map(array, function (frame) {\n                return $.extend({}, frame);\n            });\n    }\n\n    function lockScroll($el, left, top) {\n        $el\n            .scrollLeft(left || 0)\n            .scrollTop(top || 0);\n    }\n\n    function optionsToLowerCase(options) {\n        if (options) {\n            var opts = {};\n            $.each(options, function (key, value) {\n                opts[key.toLowerCase()] = value;\n            });\n\n            return opts;\n        }\n    }\n\n    function getRatio(_ratio) {\n        if (!_ratio) return;\n        var ratio = +_ratio;\n        if (!isNaN(ratio)) {\n            return ratio;\n        } else {\n            ratio = _ratio.split('/');\n            return +ratio[0] / +ratio[1] || undefined;\n        }\n    }\n\n    function addEvent(el, e, fn, bool) {\n        if (!e) return;\n        el.addEventListener ? el.addEventListener(e, fn, !!bool) : el.attachEvent('on' + e, fn);\n    }\n\n    /**\n     *\n     * @param position guess position for navShaft\n     * @param restriction object contains min and max values for position\n     * @returns {*} filtered value of position\n     */\n    function validateRestrictions(position, restriction) {\n        if (position > restriction.max) {\n            position = restriction.max;\n        } else {\n            if (position < restriction.min) {\n                position = restriction.min;\n            }\n        }\n        return position;\n    }\n\n    function validateSlidePos(opt, navShaftTouchTail, guessIndex, offsetNav, $guessNavFrame, $navWrap, dir) {\n        var position,\n            size,\n            wrapSize;\n        if (dir === 'horizontal') {\n            size = opt.thumbwidth;\n            wrapSize = $navWrap.width();\n        } else {\n            size = opt.thumbheight;\n            wrapSize = $navWrap.height();\n        }\n        if ( (size + opt.margin) * (guessIndex + 1) >= (wrapSize - offsetNav) ) {\n            if (dir === 'horizontal') {\n                position = -$guessNavFrame.position().left;\n            } else {\n                position = -$guessNavFrame.position().top;\n            }\n        } else {\n            if ((size + opt.margin) * (guessIndex) <= Math.abs(offsetNav)) {\n                if (dir === 'horizontal') {\n                    position = -$guessNavFrame.position().left + wrapSize - (size + opt.margin);\n                } else {\n                    position = -$guessNavFrame.position().top + wrapSize - (size + opt.margin);\n                }\n            } else {\n                position = offsetNav;\n            }\n        }\n        position = validateRestrictions(position, navShaftTouchTail);\n\n        return position || 0;\n    }\n\n    function elIsDisabled(el) {\n        return !!el.getAttribute('disabled');\n    }\n\n    function disableAttr(FLAG) {\n        return {tabindex: FLAG * -1 + '', disabled: FLAG};\n    }\n\n    function addEnterUp(el, fn) {\n        addEvent(el, 'keyup', function (e) {\n            elIsDisabled(el) || e.keyCode == 13 && fn.call(el, e);\n        });\n    }\n\n    function addFocus(el, fn) {\n        addEvent(el, 'focus', el.onfocusin = function (e) {\n            fn.call(el, e);\n        }, true);\n    }\n\n    function stopEvent(e, stopPropagation) {\n        e.preventDefault ? e.preventDefault() : (e.returnValue = false);\n        stopPropagation && e.stopPropagation && e.stopPropagation();\n    }\n\n    function getDirectionSign(forward) {\n        return forward ? '>' : '<';\n    }\n\n    var UTIL = (function () {\n\n        function setRatioClass($el, wh, ht) {\n            var rateImg = wh / ht;\n\n            if (rateImg <= 1) {\n                $el.parent().removeClass(horizontalImageClass);\n                $el.parent().addClass(verticalImageClass);\n            } else {\n                $el.parent().removeClass(verticalImageClass);\n                $el.parent().addClass(horizontalImageClass);\n            }\n        }\n\n        /**\n         * Set specific attribute in thumbnail template\n         * @param $frame DOM item of specific thumbnail\n         * @param value Value which must be setted into specific attribute\n         * @param searchAttr Name of attribute where value must be included\n         */\n        function setThumbAttr($frame, value, searchAttr) {\n            var attr = searchAttr;\n\n            if (!$frame.attr(attr) && $frame.attr(attr) !== undefined) {\n                $frame.attr(attr, value);\n            }\n\n            if ($frame.find(\"[\" + attr + \"]\").length) {\n                $frame.find(\"[\" + attr + \"]\")\n                    .each(function () {\n                        $(this).attr(attr, value);\n                    });\n            }\n        }\n\n        /**\n         * Method describe behavior need to render caption on preview or not\n         * @param frameItem specific item from data\n         * @param isExpected {bool} if items with caption need render them or not\n         * @returns {boolean} if true then caption should be rendered\n         */\n        function isExpectedCaption(frameItem, isExpected, undefined) {\n            var expected = false,\n                frameExpected;\n\n            frameItem.showCaption === undefined || frameItem.showCaption === true ? frameExpected = true : frameExpected = false;\n\n            if (!isExpected) {\n                return false;\n            }\n\n            if (frameItem.caption && frameExpected) {\n                expected = true;\n            }\n\n            return expected;\n        }\n\n        return {\n            setRatio: setRatioClass,\n            setThumbAttr: setThumbAttr,\n            isExpectedCaption: isExpectedCaption\n        };\n\n    }(UTIL || {}, jQuery));\n\n    function slide($el, options) {\n        var elData = $el.data(),\n            elPos = Math.round(options.pos),\n            onEndFn = function () {\n                if (elData && elData.sliding) {\n                    elData.sliding = false;\n                }\n                (options.onEnd || noop)();\n            };\n\n        if (typeof options.overPos !== 'undefined' && options.overPos !== options.pos) {\n            elPos = options.overPos;\n        }\n\n        var translate = $.extend(getTranslate(elPos, options.direction), options.width && {width: options.width}, options.height && {height: options.height});\n        if (elData && elData.sliding) {\n            elData.sliding = true;\n        }\n\n        if (CSS3) {\n            $el.css($.extend(getDuration(options.time), translate));\n\n            if (options.time > 10) {\n                afterTransition($el, 'transform', onEndFn, options.time);\n            } else {\n                onEndFn();\n            }\n        } else {\n            $el.stop().animate(translate, options.time, BEZIER, onEndFn);\n        }\n    }\n\n    function fade($el1, $el2, $frames, options, fadeStack, chain) {\n        var chainedFLAG = typeof chain !== 'undefined';\n        if (!chainedFLAG) {\n            fadeStack.push(arguments);\n            Array.prototype.push.call(arguments, fadeStack.length);\n            if (fadeStack.length > 1) return;\n        }\n\n        $el1 = $el1 || $($el1);\n        $el2 = $el2 || $($el2);\n\n        var _$el1 = $el1[0],\n            _$el2 = $el2[0],\n            crossfadeFLAG = options.method === 'crossfade',\n            onEndFn = function () {\n                if (!onEndFn.done) {\n                    onEndFn.done = true;\n                    var args = (chainedFLAG || fadeStack.shift()) && fadeStack.shift();\n                    args && fade.apply(this, args);\n                    (options.onEnd || noop)(!!args);\n                }\n            },\n            time = options.time / (chain || 1);\n\n        $frames.removeClass(fadeRearClass + ' ' + fadeFrontClass);\n\n        $el1\n            .stop()\n            .addClass(fadeRearClass);\n        $el2\n            .stop()\n            .addClass(fadeFrontClass);\n\n        crossfadeFLAG && _$el2 && $el1.fadeTo(0, 0);\n\n        $el1.fadeTo(crossfadeFLAG ? time : 0, 1, crossfadeFLAG && onEndFn);\n        $el2.fadeTo(time, 0, onEndFn);\n\n        (_$el1 && crossfadeFLAG) || _$el2 || onEndFn();\n    }\n\n    var lastEvent,\n        moveEventType,\n        preventEvent,\n        preventEventTimeout,\n        dragDomEl;\n\n    function extendEvent(e) {\n        var touch = (e.touches || [])[0] || e;\n        e._x = touch.pageX;\n        e._y = touch.clientY;\n        e._now = $.now();\n    }\n\n    function touch($el, options) {\n        var el = $el[0],\n            tail = {},\n            touchEnabledFLAG,\n            startEvent,\n            $target,\n            controlTouch,\n            touchFLAG,\n            targetIsSelectFLAG,\n            targetIsLinkFlag,\n            tolerance,\n            moved;\n\n        function onStart(e) {\n            $target = $(e.target);\n            tail.checked = targetIsSelectFLAG = targetIsLinkFlag = moved = false;\n\n            if (touchEnabledFLAG\n                || tail.flow\n                || (e.touches && e.touches.length > 1)\n                || e.which > 1\n                || (lastEvent && lastEvent.type !== e.type && preventEvent)\n                || (targetIsSelectFLAG = options.select && $target.is(options.select, el))) return targetIsSelectFLAG;\n\n            touchFLAG = e.type === 'touchstart';\n            targetIsLinkFlag = $target.is('a, a *', el);\n            controlTouch = tail.control;\n\n            tolerance = (tail.noMove || tail.noSwipe || controlTouch) ? 16 : !tail.snap ? 4 : 0;\n\n            extendEvent(e);\n\n            startEvent = lastEvent = e;\n            moveEventType = e.type.replace(/down|start/, 'move').replace(/Down/, 'Move');\n\n            (options.onStart || noop).call(el, e, {control: controlTouch, $target: $target});\n\n            touchEnabledFLAG = tail.flow = true;\n\n            if (!touchFLAG || tail.go) stopEvent(e);\n        }\n\n        function onMove(e) {\n            if ((e.touches && e.touches.length > 1)\n                || (MS_POINTER && !e.isPrimary)\n                || moveEventType !== e.type\n                || !touchEnabledFLAG) {\n                touchEnabledFLAG && onEnd();\n                (options.onTouchEnd || noop)();\n                return;\n            }\n\n            extendEvent(e);\n\n            var xDiff = Math.abs(e._x - startEvent._x), // opt _x \u00e2\u0086\u0092 _pageX\n                yDiff = Math.abs(e._y - startEvent._y),\n                xyDiff = xDiff - yDiff,\n                xWin = (tail.go || tail.x || xyDiff >= 0) && !tail.noSwipe,\n                yWin = xyDiff < 0;\n\n            if (touchFLAG && !tail.checked) {\n                if (touchEnabledFLAG = xWin) {\n                    stopEvent(e);\n                }\n            } else {\n                stopEvent(e);\n                (options.onMove || noop).call(el, e, {touch: touchFLAG});\n            }\n\n            if (!moved && Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2)) > tolerance) {\n                moved = true;\n            }\n\n            tail.checked = tail.checked || xWin || yWin;\n        }\n\n        function onEnd(e) {\n            (options.onTouchEnd || noop)();\n\n            var _touchEnabledFLAG = touchEnabledFLAG;\n            tail.control = touchEnabledFLAG = false;\n\n            if (_touchEnabledFLAG) {\n                tail.flow = false;\n            }\n\n            if (!_touchEnabledFLAG || (targetIsLinkFlag && !tail.checked)) return;\n\n            e && stopEvent(e);\n\n            preventEvent = true;\n            clearTimeout(preventEventTimeout);\n            preventEventTimeout = setTimeout(function () {\n                preventEvent = false;\n            }, 1000);\n\n            (options.onEnd || noop).call(el, {\n                moved: moved,\n                $target: $target,\n                control: controlTouch,\n                touch: touchFLAG,\n                startEvent: startEvent,\n                aborted: !e || e.type === 'MSPointerCancel'\n            });\n        }\n\n        function onOtherStart() {\n            if (tail.flow) return;\n            setTimeout(function () {\n                tail.flow = true;\n            }, 10);\n        }\n\n        function onOtherEnd() {\n            if (!tail.flow) return;\n            setTimeout(function () {\n                tail.flow = false;\n            }, TOUCH_TIMEOUT);\n        }\n\n        if (MS_POINTER) {\n            addEvent(el, 'MSPointerDown', onStart);\n            addEvent(document, 'MSPointerMove', onMove);\n            addEvent(document, 'MSPointerCancel', onEnd);\n            addEvent(document, 'MSPointerUp', onEnd);\n        } else {\n            addEvent(el, 'touchstart', onStart);\n            addEvent(el, 'touchmove', onMove);\n            addEvent(el, 'touchend', onEnd);\n\n            addEvent(document, 'touchstart', onOtherStart);\n            addEvent(document, 'touchend', onOtherEnd);\n            addEvent(document, 'touchcancel', onOtherEnd);\n\n            $WINDOW.on('scroll', onOtherEnd);\n\n            $el.on('mousedown', onStart);\n            $DOCUMENT\n                .on('mousemove', onMove)\n                .on('mouseup', onEnd);\n        }\n        if (Modernizr.touch) {\n            dragDomEl = 'a';\n        } else {\n            dragDomEl = 'div';\n        }\n        $el.on('click', dragDomEl, function (e) {\n            tail.checked && stopEvent(e);\n        });\n\n        return tail;\n    }\n\n    function moveOnTouch($el, options) {\n        var el = $el[0],\n            elData = $el.data(),\n            tail = {},\n            startCoo,\n            coo,\n            startElPos,\n            moveElPos,\n            edge,\n            moveTrack,\n            startTime,\n            endTime,\n            min,\n            max,\n            snap,\n            dir,\n            slowFLAG,\n            controlFLAG,\n            moved,\n            tracked;\n\n        function startTracking(e, noStop) {\n            tracked = true;\n            startCoo = coo = (dir === 'vertical') ? e._y : e._x;\n            startTime = e._now;\n\n            moveTrack = [\n                [startTime, startCoo]\n            ];\n\n            startElPos = moveElPos = tail.noMove || noStop ? 0 : stop($el, (options.getPos || noop)()/*, options._001*/);\n\n            (options.onStart || noop).call(el, e);\n        }\n\n        function onStart(e, result) {\n            min = tail.min;\n            max = tail.max;\n            snap = tail.snap,\n                dir = tail.direction || 'horizontal',\n                $el.navdir = dir;\n\n            slowFLAG = e.altKey;\n            tracked = moved = false;\n\n            controlFLAG = result.control;\n\n            if (!controlFLAG && !elData.sliding) {\n                startTracking(e);\n            }\n        }\n\n        function onMove(e, result) {\n            if (!tail.noSwipe) {\n                if (!tracked) {\n                    startTracking(e);\n                }\n                coo = (dir === 'vertical') ? e._y : e._x;\n\n                moveTrack.push([e._now, coo]);\n\n                moveElPos = startElPos - (startCoo - coo);\n\n                edge = findShadowEdge(moveElPos, min, max, dir);\n\n                if (moveElPos <= min) {\n                    moveElPos = edgeResistance(moveElPos, min);\n                } else if (moveElPos >= max) {\n                    moveElPos = edgeResistance(moveElPos, max);\n                }\n\n                if (!tail.noMove) {\n                    $el.css(getTranslate(moveElPos, dir));\n                    if (!moved) {\n                        moved = true;\n                        // only for mouse\n                        result.touch || MS_POINTER || $el.addClass(grabbingClass);\n                    }\n\n                    (options.onMove || noop).call(el, e, {pos: moveElPos, edge: edge});\n                }\n            }\n        }\n\n        function onEnd(result) {\n            if (tail.noSwipe && result.moved) return;\n\n            if (!tracked) {\n                startTracking(result.startEvent, true);\n            }\n\n            result.touch || MS_POINTER || $el.removeClass(grabbingClass);\n\n            endTime = $.now();\n\n            var _backTimeIdeal = endTime - TOUCH_TIMEOUT,\n                _backTime,\n                _timeDiff,\n                _timeDiffLast,\n                backTime = null,\n                backCoo,\n                virtualPos,\n                limitPos,\n                newPos,\n                overPos,\n                time = TRANSITION_DURATION,\n                speed,\n                friction = options.friction;\n\n            for (var _i = moveTrack.length - 1; _i >= 0; _i--) {\n                _backTime = moveTrack[_i][0];\n                _timeDiff = Math.abs(_backTime - _backTimeIdeal);\n                if (backTime === null || _timeDiff < _timeDiffLast) {\n                    backTime = _backTime;\n                    backCoo = moveTrack[_i][1];\n                } else if (backTime === _backTimeIdeal || _timeDiff > _timeDiffLast) {\n                    break;\n                }\n                _timeDiffLast = _timeDiff;\n            }\n\n            newPos = minMaxLimit(moveElPos, min, max);\n\n            var cooDiff = backCoo - coo,\n                forwardFLAG = cooDiff >= 0,\n                timeDiff = endTime - backTime,\n                longTouchFLAG = timeDiff > TOUCH_TIMEOUT,\n                swipeFLAG = !longTouchFLAG && moveElPos !== startElPos && newPos === moveElPos;\n\n            if (snap) {\n                newPos = minMaxLimit(Math[swipeFLAG ? (forwardFLAG ? 'floor' : 'ceil') : 'round'](moveElPos / snap) * snap, min, max);\n                min = max = newPos;\n            }\n\n            if (swipeFLAG && (snap || newPos === moveElPos)) {\n                speed = -(cooDiff / timeDiff);\n                time *= minMaxLimit(Math.abs(speed), options.timeLow, options.timeHigh);\n                virtualPos = Math.round(moveElPos + speed * time / friction);\n\n                if (!snap) {\n                    newPos = virtualPos;\n                }\n\n                if (!forwardFLAG && virtualPos > max || forwardFLAG && virtualPos < min) {\n                    limitPos = forwardFLAG ? min : max;\n                    overPos = virtualPos - limitPos;\n                    if (!snap) {\n                        newPos = limitPos;\n                    }\n                    overPos = minMaxLimit(newPos + overPos * .03, limitPos - 50, limitPos + 50);\n                    time = Math.abs((moveElPos - overPos) / (speed / friction));\n                }\n            }\n\n            time *= slowFLAG ? 10 : 1;\n\n            (options.onEnd || noop).call(el, $.extend(result, {\n                moved: result.moved || longTouchFLAG && snap,\n                pos: moveElPos,\n                newPos: newPos,\n                overPos: overPos,\n                time: time,\n                dir: dir\n            }));\n        }\n\n        tail = $.extend(touch(options.$wrap, $.extend({}, options, {\n            onStart: onStart,\n            onMove: onMove,\n            onEnd: onEnd\n        })), tail);\n\n        return tail;\n    }\n\n    function wheel($el, options) {\n        var el = $el[0],\n            lockFLAG,\n            lastDirection,\n            lastNow,\n            tail = {\n                prevent: {}\n            };\n\n        addEvent(el, WHEEL, function (e) {\n            var yDelta = e.wheelDeltaY || -1 * e.deltaY || 0,\n                xDelta = e.wheelDeltaX || -1 * e.deltaX || 0,\n                xWin = Math.abs(xDelta) && !Math.abs(yDelta),\n                direction = getDirectionSign(xDelta < 0),\n                sameDirection = lastDirection === direction,\n                now = $.now(),\n                tooFast = now - lastNow < TOUCH_TIMEOUT;\n\n            lastDirection = direction;\n            lastNow = now;\n\n            if (!xWin || !tail.ok || tail.prevent[direction] && !lockFLAG) {\n                return;\n            } else {\n                stopEvent(e, true);\n                if (lockFLAG && sameDirection && tooFast) {\n                    return;\n                }\n            }\n\n            if (options.shift) {\n                lockFLAG = true;\n                clearTimeout(tail.t);\n                tail.t = setTimeout(function () {\n                    lockFLAG = false;\n                }, SCROLL_LOCK_TIMEOUT);\n            }\n\n            (options.onEnd || noop)(e, options.shift ? direction : xDelta);\n\n        });\n\n        return tail;\n    }\n\n    jQuery.Fotorama = function ($fotorama, opts) {\n        $HTML = $('html');\n        $BODY = $('body');\n\n        var that = this,\n            stamp = $.now(),\n            stampClass = _fotoramaClass + stamp,\n            fotorama = $fotorama[0],\n            data,\n            dataFrameCount = 1,\n            fotoramaData = $fotorama.data(),\n            size,\n\n            $style = $('<style></style>'),\n\n            $anchor = $(div(hiddenClass)),\n            $wrap = $fotorama.find(cls(wrapClass)),\n            $stage = $wrap.find(cls(stageClass)),\n            stage = $stage[0],\n\n            $stageShaft = $fotorama.find(cls(stageShaftClass)),\n            $stageFrame = $(),\n            $arrPrev = $fotorama.find(cls(arrPrevClass)),\n            $arrNext = $fotorama.find(cls(arrNextClass)),\n            $arrs = $fotorama.find(cls(arrClass)),\n            $navWrap = $fotorama.find(cls(navWrapClass)),\n            $nav = $navWrap.find(cls(navClass)),\n            $navShaft = $nav.find(cls(navShaftClass)),\n            $navFrame,\n            $navDotFrame = $(),\n            $navThumbFrame = $(),\n\n            stageShaftData = $stageShaft.data(),\n            navShaftData = $navShaft.data(),\n\n            $thumbBorder = $fotorama.find(cls(thumbBorderClass)),\n            $thumbArrLeft = $fotorama.find(cls(thumbArrLeft)),\n            $thumbArrRight = $fotorama.find(cls(thumbArrRight)),\n\n            $fullscreenIcon = $fotorama.find(cls(fullscreenIconClass)),\n            fullscreenIcon = $fullscreenIcon[0],\n            $videoPlay = $(div(videoPlayClass)),\n            $videoClose = $fotorama.find(cls(videoCloseClass)),\n            videoClose = $videoClose[0],\n\n            spinner,\n            $spinner = $(div(spinnerClass)),\n\n            $videoPlaying,\n\n            activeIndex = false,\n            activeFrame,\n            activeIndexes,\n            repositionIndex,\n            dirtyIndex,\n            lastActiveIndex,\n            prevIndex,\n            nextIndex,\n            nextAutoplayIndex,\n            startIndex,\n\n            o_loop,\n            o_nav,\n            o_navThumbs,\n            o_navTop,\n            o_allowFullScreen,\n            o_nativeFullScreen,\n            o_fade,\n            o_thumbSide,\n            o_thumbSide2,\n            o_transitionDuration,\n            o_transition,\n            o_shadows,\n            o_rtl,\n            o_keyboard,\n            lastOptions = {},\n\n            measures = {},\n            measuresSetFLAG,\n\n            stageShaftTouchTail = {},\n            stageWheelTail = {},\n            navShaftTouchTail = {},\n            navWheelTail = {},\n\n            scrollTop,\n            scrollLeft,\n\n            showedFLAG,\n            pausedAutoplayFLAG,\n            stoppedAutoplayFLAG,\n\n            toDeactivate = {},\n            toDetach = {},\n\n            measuresStash,\n\n            touchedFLAG,\n\n            hoverFLAG,\n\n            navFrameKey,\n            stageLeft = 0,\n\n            fadeStack = [];\n\n        $wrap[STAGE_FRAME_KEY] = $('<div class=\"' + stageFrameClass + '\"></div>');\n        $wrap[NAV_THUMB_FRAME_KEY] = $($.Fotorama.jst.thumb());\n        $wrap[NAV_DOT_FRAME_KEY] = $($.Fotorama.jst.dots());\n\n        toDeactivate[STAGE_FRAME_KEY] = [];\n        toDeactivate[NAV_THUMB_FRAME_KEY] = [];\n        toDeactivate[NAV_DOT_FRAME_KEY] = [];\n        toDetach[STAGE_FRAME_KEY] = {};\n\n        $wrap.addClass(CSS3 ? wrapCss3Class : wrapCss2Class);\n\n        fotoramaData.fotorama = this;\n\n        /**\n         * Search video items in incomming data and transform object for video layout.\n         *\n         */\n        function checkForVideo() {\n            $.each(data, function (i, dataFrame) {\n                if (!dataFrame.i) {\n                    dataFrame.i = dataFrameCount++;\n                    var video = findVideoId(dataFrame.video, true);\n                    if (video) {\n                        var thumbs = {};\n                        dataFrame.video = video;\n                        if (!dataFrame.img && !dataFrame.thumb) {\n                            thumbs = getVideoThumbs(dataFrame, data, that);\n                        } else {\n                            dataFrame.thumbsReady = true;\n                        }\n                        updateData(data, {img: thumbs.img, thumb: thumbs.thumb}, dataFrame.i, that);\n                    }\n                }\n            });\n        }\n\n        function allowKey(key) {\n            return o_keyboard[key] || that.fullScreen;\n        }\n\n        function setStagePosition() {\n            if ($stage !== undefined) {\n\n                if (opts.navdir == 'vertical') {\n                    var padding = opts.thumbwidth + opts.thumbmargin;\n\n                    $stage.css('left', padding);\n                    $arrNext.css('right', padding);\n                    $fullscreenIcon.css('right', padding);\n                    $wrap.css('width', $wrap.css('width') + padding);\n                    $stageShaft.css('max-width', $wrap.width() - padding);\n                } else {\n                    $stage.css('left', '');\n                    $arrNext.css('right', '');\n                    $fullscreenIcon.css('right', '');\n                    $wrap.css('width', $wrap.css('width') + padding);\n                    $stageShaft.css('max-width', '');\n                }\n            }\n        }\n\n        function bindGlobalEvents(FLAG) {\n            var keydownCommon = 'keydown.' + _fotoramaClass,\n                localStamp = _fotoramaClass + stamp,\n                keydownLocal = 'keydown.' + localStamp,\n                keyupLocal = 'keyup.' + localStamp,\n                resizeLocal = 'resize.' + localStamp + ' ' + 'orientationchange.' + localStamp,\n                showParams;\n\n            if (FLAG) {\n                $DOCUMENT\n                    .on(keydownLocal, function (e) {\n                        var catched,\n                            index;\n\n                        if ($videoPlaying && e.keyCode === 27) {\n                            catched = true;\n                            unloadVideo($videoPlaying, true, true);\n                        } else if (that.fullScreen || (opts.keyboard && !that.index)) {\n                            if (e.keyCode === 27) {\n                                catched = true;\n                                that.cancelFullScreen();\n                            } else if ((e.shiftKey && e.keyCode === 32 && allowKey('space')) || (e.keyCode === 37 && allowKey('left')) || (e.keyCode === 38 && allowKey('up'))) {\n                                that.longPress.progress();\n                                index = '<';\n                            } else if ((e.keyCode === 32 && allowKey('space')) || (e.keyCode === 39 && allowKey('right')) || (e.keyCode === 40 && allowKey('down'))) {\n                                that.longPress.progress();\n                                index = '>';\n                            } else if (e.keyCode === 36 && allowKey('home')) {\n                                that.longPress.progress();\n                                index = '<<';\n                            } else if (e.keyCode === 35 && allowKey('end')) {\n                                that.longPress.progress();\n                                index = '>>';\n                            }\n                        }\n\n                        (catched || index) && stopEvent(e);\n                        showParams = {index: index, slow: e.altKey, user: true};\n                        index && (that.longPress.inProgress ?\n                            that.showWhileLongPress(showParams) :\n                            that.show(showParams));\n                    });\n\n                if (FLAG) {\n                    $DOCUMENT\n                        .on(keyupLocal, function (e) {\n                            if (that.longPress.inProgress) {\n                                that.showEndLongPress({user:true});\n                            }\n                            that.longPress.reset();\n                        });\n                }\n\n                if (!that.index) {\n                    $DOCUMENT\n                        .off(keydownCommon)\n                        .on(keydownCommon, 'textarea, input, select', function (e) {\n                            !$BODY.hasClass(_fullscreenClass) && e.stopPropagation();\n                        });\n                }\n\n                $WINDOW.on(resizeLocal, that.resize);\n            } else {\n                $DOCUMENT.off(keydownLocal);\n                $WINDOW.off(resizeLocal);\n            }\n        }\n\n        function appendElements(FLAG) {\n            if (FLAG === appendElements.f) return;\n\n            if (FLAG) {\n                $fotorama\n                    .addClass(_fotoramaClass + ' ' + stampClass)\n                    .before($anchor)\n                    .before($style);\n                addInstance(that);\n            } else {\n                $anchor.detach();\n                $style.detach();\n                $fotorama\n                    .html(fotoramaData.urtext)\n                    .removeClass(stampClass);\n\n                hideInstance(that);\n            }\n\n            bindGlobalEvents(FLAG);\n            appendElements.f = FLAG;\n        }\n\n        /**\n         * Set and install data from incomming @param {JSON} options or takes data attr from data-\"name\"=... values.\n         */\n        function setData() {\n            data = that.data = data || clone(opts.data) || getDataFromHtml($fotorama);\n            size = that.size = data.length;\n\n            ready.ok && opts.shuffle && shuffle(data);\n\n            checkForVideo();\n\n            activeIndex = limitIndex(activeIndex);\n\n            size && appendElements(true);\n        }\n\n        function stageNoMove() {\n            var _noMove = size < 2 || $videoPlaying;\n            stageShaftTouchTail.noMove = _noMove || o_fade;\n            stageShaftTouchTail.noSwipe = _noMove || !opts.swipe;\n\n            !o_transition && $stageShaft.toggleClass(grabClass, !opts.click && !stageShaftTouchTail.noMove && !stageShaftTouchTail.noSwipe);\n            MS_POINTER && $wrap.toggleClass(wrapPanYClass, !stageShaftTouchTail.noSwipe);\n        }\n\n        function setAutoplayInterval(interval) {\n            if (interval === true) interval = '';\n            opts.autoplay = Math.max(+interval || AUTOPLAY_INTERVAL, o_transitionDuration * 1.5);\n        }\n\n        function updateThumbArrow(opt) {\n            if (opt.navarrows && opt.nav === 'thumbs') {\n                $thumbArrLeft.show();\n                $thumbArrRight.show();\n            } else {\n                $thumbArrLeft.hide();\n                $thumbArrRight.hide();\n            }\n\n        }\n\n        function getThumbsInSlide($el, opts) {\n            return Math.floor($wrap.width() / (opts.thumbwidth + opts.thumbmargin));\n        }\n\n        /**\n         * Options on the fly\n         * */\n        function setOptions() {\n            if (!opts.nav || opts.nav === 'dots') {\n                opts.navdir = 'horizontal'\n            }\n\n            that.options = opts = optionsToLowerCase(opts);\n            thumbsPerSlide = getThumbsInSlide($wrap, opts);\n\n            o_fade = (opts.transition === 'crossfade' || opts.transition === 'dissolve');\n\n            o_loop = opts.loop && (size > 2 || (o_fade && (!o_transition || o_transition !== 'slide')));\n\n            o_transitionDuration = +opts.transitionduration || TRANSITION_DURATION;\n\n            o_rtl = opts.direction === 'rtl';\n\n            o_keyboard = $.extend({}, opts.keyboard && KEYBOARD_OPTIONS, opts.keyboard);\n            updateThumbArrow(opts);\n            var classes = {add: [], remove: []};\n\n            function addOrRemoveClass(FLAG, value) {\n                classes[FLAG ? 'add' : 'remove'].push(value);\n            }\n\n            if (size > 1) {\n                o_nav = opts.nav;\n                o_navTop = opts.navposition === 'top';\n                classes.remove.push(selectClass);\n\n                $arrs.toggle(opts.arrows);\n            } else {\n                o_nav = false;\n                $arrs.hide();\n            }\n\n            spinnerStop();\n            spinner = new Spinner($.extend(spinnerDefaults, opts.spinner, spinnerOverride, {direction: o_rtl ? -1 : 1}));\n\n            arrsUpdate();\n            stageWheelUpdate();\n            thumbArrUpdate();\n            if (opts.autoplay) setAutoplayInterval(opts.autoplay);\n\n            o_thumbSide = numberFromMeasure(opts.thumbwidth) || THUMB_SIZE;\n            o_thumbSide2 = numberFromMeasure(opts.thumbheight) || THUMB_SIZE;\n\n            stageWheelTail.ok = navWheelTail.ok = opts.trackpad && !SLOW;\n\n            stageNoMove();\n\n            extendMeasures(opts, [measures]);\n\n            o_navThumbs = o_nav === 'thumbs';\n\n            if ($navWrap.filter(':hidden') && !!o_nav) {\n                $navWrap.show();\n            }\n            if (o_navThumbs) {\n                frameDraw(size, 'navThumb');\n\n                $navFrame = $navThumbFrame;\n                navFrameKey = NAV_THUMB_FRAME_KEY;\n\n                setStyle($style, $.Fotorama.jst.style({\n                    w: o_thumbSide,\n                    h: o_thumbSide2,\n                    b: opts.thumbborderwidth,\n                    m: opts.thumbmargin,\n                    s: stamp,\n                    q: !COMPAT\n                }));\n\n                $nav\n                    .addClass(navThumbsClass)\n                    .removeClass(navDotsClass);\n            } else if (o_nav === 'dots') {\n                frameDraw(size, 'navDot');\n\n                $navFrame = $navDotFrame;\n                navFrameKey = NAV_DOT_FRAME_KEY;\n\n                $nav\n                    .addClass(navDotsClass)\n                    .removeClass(navThumbsClass);\n            } else {\n                $navWrap.hide();\n                o_nav = false;\n                $nav.removeClass(navThumbsClass + ' ' + navDotsClass);\n            }\n\n            if (o_nav) {\n                if (o_navTop) {\n                    $navWrap.insertBefore($stage);\n                } else {\n                    $navWrap.insertAfter($stage);\n                }\n                frameAppend.nav = false;\n\n                frameAppend($navFrame, $navShaft, 'nav');\n            }\n\n            o_allowFullScreen = opts.allowfullscreen;\n\n            if (o_allowFullScreen) {\n                $fullscreenIcon.prependTo($stage);\n                o_nativeFullScreen = FULLSCREEN && o_allowFullScreen === 'native';\n            } else {\n                $fullscreenIcon.detach();\n                o_nativeFullScreen = false;\n            }\n\n            addOrRemoveClass(o_fade, wrapFadeClass);\n            addOrRemoveClass(!o_fade, wrapSlideClass);\n            addOrRemoveClass(!opts.captions, wrapNoCaptionsClass);\n            addOrRemoveClass(o_rtl, wrapRtlClass);\n            addOrRemoveClass(opts.arrows !== 'always', wrapToggleArrowsClass);\n\n            o_shadows = opts.shadows && !SLOW;\n            addOrRemoveClass(!o_shadows, wrapNoShadowsClass);\n\n            $wrap\n                .addClass(classes.add.join(' '))\n                .removeClass(classes.remove.join(' '));\n\n            lastOptions = $.extend({}, opts);\n            setStagePosition();\n        }\n\n        function normalizeIndex(index) {\n            return index < 0 ? (size + (index % size)) % size : index >= size ? index % size : index;\n        }\n\n        function limitIndex(index) {\n            return minMaxLimit(index, 0, size - 1);\n        }\n\n        function edgeIndex(index) {\n            return o_loop ? normalizeIndex(index) : limitIndex(index);\n        }\n\n        function getPrevIndex(index) {\n            return index > 0 || o_loop ? index - 1 : false;\n        }\n\n        function getNextIndex(index) {\n            return index < size - 1 || o_loop ? index + 1 : false;\n        }\n\n        function setStageShaftMinmaxAndSnap() {\n            stageShaftTouchTail.min = o_loop ? -Infinity : -getPosByIndex(size - 1, measures.w, opts.margin, repositionIndex);\n            stageShaftTouchTail.max = o_loop ? Infinity : -getPosByIndex(0, measures.w, opts.margin, repositionIndex);\n            stageShaftTouchTail.snap = measures.w + opts.margin;\n        }\n\n        function setNavShaftMinMax() {\n\n            var isVerticalDir = (opts.navdir === 'vertical');\n            var param = isVerticalDir ? $navShaft.height() : $navShaft.width();\n            var mainParam = isVerticalDir ? measures.h : measures.nw;\n            navShaftTouchTail.min = Math.min(0, mainParam - param);\n            navShaftTouchTail.max = 0;\n            navShaftTouchTail.direction = opts.navdir;\n            $navShaft.toggleClass(grabClass, !(navShaftTouchTail.noMove = navShaftTouchTail.min === navShaftTouchTail.max));\n        }\n\n        function eachIndex(indexes, type, fn) {\n            if (typeof indexes === 'number') {\n                indexes = new Array(indexes);\n                var rangeFLAG = true;\n            }\n            return $.each(indexes, function (i, index) {\n                if (rangeFLAG) index = i;\n                if (typeof index === 'number') {\n                    var dataFrame = data[normalizeIndex(index)];\n\n                    if (dataFrame) {\n                        var key = '$' + type + 'Frame',\n                            $frame = dataFrame[key];\n\n                        fn.call(this, i, index, dataFrame, $frame, key, $frame && $frame.data());\n                    }\n                }\n            });\n        }\n\n        function setMeasures(width, height, ratio, index) {\n            if (!measuresSetFLAG || (measuresSetFLAG === '*' && index === startIndex)) {\n\n                width = measureIsValid(opts.width) || measureIsValid(width) || WIDTH;\n                height = measureIsValid(opts.height) || measureIsValid(height) || HEIGHT;\n                that.resize({\n                    width: width,\n                    ratio: opts.ratio || ratio || width / height\n                }, 0, index !== startIndex && '*');\n            }\n        }\n\n        function loadImg(indexes, type, specialMeasures, again) {\n            eachIndex(indexes, type, function (i, index, dataFrame, $frame, key, frameData) {\n\n                if (!$frame) return;\n\n                var fullFLAG = that.fullScreen && dataFrame.full && dataFrame.full !== dataFrame.img && !frameData.$full && type === 'stage';\n\n                if (frameData.$img && !again && !fullFLAG) return;\n\n                var img = new Image(),\n                    $img = $(img),\n                    imgData = $img.data();\n\n                frameData[fullFLAG ? '$full' : '$img'] = $img;\n\n                var srcKey = type === 'stage' ? (fullFLAG ? 'full' : 'img') : 'thumb',\n                    src = dataFrame[srcKey],\n                    dummy = fullFLAG ? null : dataFrame[type === 'stage' ? 'thumb' : 'img'];\n\n                if (type === 'navThumb') $frame = frameData.$wrap;\n\n                function triggerTriggerEvent(event) {\n                    var _index = normalizeIndex(index);\n                    triggerEvent(event, {\n                        index: _index,\n                        src: src,\n                        frame: data[_index]\n                    });\n                }\n\n                function error() {\n                    $img.remove();\n\n                    $.Fotorama.cache[src] = 'error';\n\n                    if ((!dataFrame.html || type !== 'stage') && dummy && dummy !== src) {\n                        dataFrame[srcKey] = src = dummy;\n                        loadImg([index], type, specialMeasures, true);\n                    } else {\n                        if (src && !dataFrame.html && !fullFLAG) {\n                            $frame\n                                .trigger('f:error')\n                                .removeClass(loadingClass)\n                                .addClass(errorClass);\n\n                            triggerTriggerEvent('error');\n                        } else if (type === 'stage') {\n                            $frame\n                                .trigger('f:load')\n                                .removeClass(loadingClass + ' ' + errorClass)\n                                .addClass(loadedClass);\n\n                            triggerTriggerEvent('load');\n                            setMeasures();\n                        }\n\n                        frameData.state = 'error';\n\n                        if (size > 1 && data[index] === dataFrame && !dataFrame.html && !dataFrame.deleted && !dataFrame.video && !fullFLAG) {\n                            dataFrame.deleted = true;\n                            that.splice(index, 1);\n                        }\n                    }\n                }\n\n                function loaded() {\n                    $.Fotorama.measures[src] = imgData.measures = $.Fotorama.measures[src] || {\n                            width: img.width,\n                            height: img.height,\n                            ratio: img.width / img.height\n                        };\n\n                    setMeasures(imgData.measures.width, imgData.measures.height, imgData.measures.ratio, index);\n\n                    $img\n                        .off('load error')\n                        .addClass(imgClass + (fullFLAG ? ' ' + imgFullClass : ''))\n                        .prependTo($frame);\n\n                    if ($frame.hasClass(stageFrameClass) && !$frame.hasClass(videoContainerClass)) {\n                        $frame.attr(\"href\", $img.attr(\"src\"));\n                    }\n\n                    fit($img, (\n                            $.isFunction(specialMeasures) ? specialMeasures() : specialMeasures) || measures);\n\n                    $.Fotorama.cache[src] = frameData.state = 'loaded';\n\n                    setTimeout(function () {\n                        $frame\n                            .trigger('f:load')\n                            .removeClass(loadingClass + ' ' + errorClass)\n                            .addClass(loadedClass + ' ' + (fullFLAG ? loadedFullClass : loadedImgClass));\n\n                        if (type === 'stage') {\n                            triggerTriggerEvent('load');\n                        } else if (dataFrame.thumbratio === AUTO || !dataFrame.thumbratio && opts.thumbratio === AUTO) {\n                            // danger! reflow for all thumbnails\n                            dataFrame.thumbratio = imgData.measures.ratio;\n                            reset();\n                        }\n                    }, 0);\n                }\n\n                if (!src) {\n                    error();\n                    return;\n                }\n\n                function waitAndLoad() {\n                    var _i = 10;\n                    waitFor(function () {\n                        return !touchedFLAG || !_i-- && !SLOW;\n                    }, function () {\n                        loaded();\n                    });\n                }\n\n                if (!$.Fotorama.cache[src]) {\n                    $.Fotorama.cache[src] = '*';\n\n                    $img\n                        .on('load', waitAndLoad)\n                        .on('error', error);\n                } else {\n                    (function justWait() {\n                        if ($.Fotorama.cache[src] === 'error') {\n                            error();\n                        } else if ($.Fotorama.cache[src] === 'loaded') {\n                            setTimeout(waitAndLoad, 0);\n                        } else {\n                            setTimeout(justWait, 100);\n                        }\n                    })();\n                }\n\n                frameData.state = '';\n                img.src = src;\n\n                if (frameData.data.caption) {\n                    img.alt = frameData.data.caption || \"\";\n                }\n\n                if (UTIL.isExpectedCaption(dataFrame, opts.showcaption)) {\n                    $(img).attr('aria-labelledby', dataFrame.labelledby);\n                }\n            });\n        }\n\n        function spinnerSpin($el) {\n            $spinner.append(spinner.spin().el).appendTo($el);\n        }\n\n        function spinnerStop() {\n            $spinner.detach();\n            spinner && spinner.stop();\n        }\n\n        function updateFotoramaState() {\n            var $frame = activeFrame[STAGE_FRAME_KEY];\n\n            if ($frame && !$frame.data().state) {\n                spinnerSpin($frame);\n                $frame.on('f:load f:error', function () {\n                    $frame.off('f:load f:error');\n                    spinnerStop();\n                });\n            }\n        }\n\n        function addNavFrameEvents(frame) {\n            addEnterUp(frame, onNavFrameClick);\n            addFocus(frame, function () {\n\n                setTimeout(function () {\n                    lockScroll($nav);\n                }, 0);\n                slideNavShaft({time: o_transitionDuration, guessIndex: $(this).data().eq, minMax: navShaftTouchTail});\n            });\n        }\n\n        function frameDraw(indexes, type) {\n            eachIndex(indexes, type, function (i, index, dataFrame, $frame, key, frameData) {\n                if ($frame) return;\n\n                $frame = dataFrame[key] = $wrap[key].clone();\n                frameData = $frame.data();\n                frameData.data = dataFrame;\n                var frame = $frame[0],\n                    labelledbyValue = \"labelledby\" + $.now();\n\n                if (type === 'stage') {\n\n                    if (dataFrame.html) {\n                        $('<div class=\"' + htmlClass + '\"></div>')\n                            .append(\n                            dataFrame._html ? $(dataFrame.html)\n                                .removeAttr('id')\n                                .html(dataFrame._html) // Because of IE\n                                : dataFrame.html\n                        )\n                            .appendTo($frame);\n                    }\n\n                    if (dataFrame.id) {\n                        labelledbyValue = dataFrame.id || labelledbyValue;\n                    }\n                    dataFrame.labelledby = labelledbyValue;\n\n                    if (UTIL.isExpectedCaption(dataFrame, opts.showcaption)) {\n                        $($.Fotorama.jst.frameCaption({\n                            caption: dataFrame.caption,\n                            labelledby: labelledbyValue\n                        })).appendTo($frame);\n                    }\n\n                    dataFrame.video && $frame\n                        .addClass(stageFrameVideoClass)\n                        .append($videoPlay.clone());\n\n                    // This solves tabbing problems\n                    addFocus(frame, function () {\n                        setTimeout(function () {\n                            lockScroll($stage);\n                        }, 0);\n                        clickToShow({index: frameData.eq, user: true});\n                    });\n\n                    $stageFrame = $stageFrame.add($frame);\n                } else if (type === 'navDot') {\n                    addNavFrameEvents(frame);\n                    $navDotFrame = $navDotFrame.add($frame);\n                } else if (type === 'navThumb') {\n                    addNavFrameEvents(frame);\n                    frameData.$wrap = $frame.children(':first');\n\n                    $navThumbFrame = $navThumbFrame.add($frame);\n                    if (dataFrame.video) {\n                        frameData.$wrap.append($videoPlay.clone());\n                    }\n                }\n            });\n        }\n\n        function callFit($img, measuresToFit) {\n            return $img && $img.length && fit($img, measuresToFit);\n        }\n\n        function stageFramePosition(indexes) {\n            eachIndex(indexes, 'stage', function (i, index, dataFrame, $frame, key, frameData) {\n                if (!$frame) return;\n\n                var normalizedIndex = normalizeIndex(index);\n                frameData.eq = normalizedIndex;\n\n                toDetach[STAGE_FRAME_KEY][normalizedIndex] = $frame.css($.extend({left: o_fade ? 0 : getPosByIndex(index, measures.w, opts.margin, repositionIndex)}, o_fade && getDuration(0)));\n\n                if (isDetached($frame[0])) {\n                    $frame.appendTo($stageShaft);\n                    unloadVideo(dataFrame.$video);\n                }\n\n                callFit(frameData.$img, measures);\n                callFit(frameData.$full, measures);\n\n                if ($frame.hasClass(stageFrameClass) && !($frame.attr('aria-hidden') === \"false\" && $frame.hasClass(activeClass))) {\n                    $frame.attr('aria-hidden', 'true');\n                }\n            });\n        }\n\n        function thumbsDraw(pos, loadFLAG) {\n            var leftLimit,\n                rightLimit,\n                exceedLimit;\n\n\n            if (o_nav !== 'thumbs' || isNaN(pos)) return;\n\n            leftLimit = -pos;\n            rightLimit = -pos + measures.nw;\n\n            if (opts.navdir === 'vertical') {\n                pos = pos - opts.thumbheight;\n                rightLimit = -pos + measures.h;\n            }\n\n            $navThumbFrame.each(function () {\n                var $this = $(this),\n                    thisData = $this.data(),\n                    eq = thisData.eq,\n                    getSpecialMeasures = function () {\n                        return {\n                            h: o_thumbSide2,\n                            w: thisData.w\n                        }\n                    },\n                    specialMeasures = getSpecialMeasures(),\n                    exceedLimit = opts.navdir === 'vertical' ?\n                    thisData.t > rightLimit : thisData.l > rightLimit;\n                specialMeasures.w = thisData.w;\n\n                if (thisData.l + thisData.w < leftLimit\n                    || exceedLimit\n                    || callFit(thisData.$img, specialMeasures)) return;\n\n                loadFLAG && loadImg([eq], 'navThumb', getSpecialMeasures);\n            });\n        }\n\n        function frameAppend($frames, $shaft, type) {\n            if (!frameAppend[type]) {\n\n                var thumbsFLAG = type === 'nav' && o_navThumbs,\n                    left = 0,\n                    top = 0;\n\n                $shaft.append(\n                    $frames\n                        .filter(function () {\n                            var actual,\n                                $this = $(this),\n                                frameData = $this.data();\n                            for (var _i = 0, _l = data.length; _i < _l; _i++) {\n                                if (frameData.data === data[_i]) {\n                                    actual = true;\n                                    frameData.eq = _i;\n                                    break;\n                                }\n                            }\n                            return actual || $this.remove() && false;\n                        })\n                        .sort(function (a, b) {\n                            return $(a).data().eq - $(b).data().eq;\n                        })\n                        .each(function () {\n                            var $this = $(this),\n                                frameData = $this.data();\n                            UTIL.setThumbAttr($this, frameData.data.caption, \"aria-label\");\n                        })\n                        .each(function () {\n\n                            if (!thumbsFLAG) return;\n\n                            var $this = $(this),\n                                frameData = $this.data(),\n                                thumbwidth = Math.round(o_thumbSide2 * frameData.data.thumbratio) || o_thumbSide,\n                                thumbheight = Math.round(o_thumbSide / frameData.data.thumbratio) || o_thumbSide2;\n                            frameData.t = top;\n                            frameData.h = thumbheight;\n                            frameData.l = left;\n                            frameData.w = thumbwidth;\n\n                            $this.css({width: thumbwidth});\n\n                            top += thumbheight + opts.thumbmargin;\n                            left += thumbwidth + opts.thumbmargin;\n                        })\n                );\n\n                frameAppend[type] = true;\n            }\n        }\n\n        function getDirection(x) {\n            return x - stageLeft > measures.w / 3;\n        }\n\n        function disableDirrection(i) {\n            return !o_loop && (!(activeIndex + i) || !(activeIndex - size + i)) && !$videoPlaying;\n        }\n\n        function arrsUpdate() {\n            var disablePrev = disableDirrection(0),\n                disableNext = disableDirrection(1);\n            $arrPrev\n                .toggleClass(arrDisabledClass, disablePrev)\n                .attr(disableAttr(disablePrev));\n            $arrNext\n                .toggleClass(arrDisabledClass, disableNext)\n                .attr(disableAttr(disableNext));\n        }\n\n        function thumbArrUpdate() {\n            var isLeftDisable = false,\n                isRightDisable = false;\n            if (opts.navtype === 'thumbs' && !opts.loop) {\n                (activeIndex == 0) ? isLeftDisable = true : isLeftDisable = false;\n                (activeIndex == opts.data.length - 1) ? isRightDisable = true : isRightDisable = false;\n            }\n            if (opts.navtype === 'slides') {\n                var pos = readPosition($navShaft, opts.navdir);\n                pos >= navShaftTouchTail.max ? isLeftDisable = true : isLeftDisable = false;\n                pos <= navShaftTouchTail.min ? isRightDisable = true : isRightDisable = false;\n            }\n            $thumbArrLeft\n                .toggleClass(arrDisabledClass, isLeftDisable)\n                .attr(disableAttr(isLeftDisable));\n            $thumbArrRight\n                .toggleClass(arrDisabledClass, isRightDisable)\n                .attr(disableAttr(isRightDisable));\n        }\n\n        function stageWheelUpdate() {\n            if (stageWheelTail.ok) {\n                stageWheelTail.prevent = {'<': disableDirrection(0), '>': disableDirrection(1)};\n            }\n        }\n\n        function getNavFrameBounds($navFrame) {\n            var navFrameData = $navFrame.data(),\n                left,\n                top,\n                width,\n                height;\n\n            if (o_navThumbs) {\n                left = navFrameData.l;\n                top = navFrameData.t;\n                width = navFrameData.w;\n                height = navFrameData.h;\n            } else {\n                left = $navFrame.position().left;\n                width = $navFrame.width();\n            }\n\n            var horizontalBounds = {\n                c: left + width / 2,\n                min: -left + opts.thumbmargin * 10,\n                max: -left + measures.w - width - opts.thumbmargin * 10\n            };\n\n            var verticalBounds = {\n                c: top + height / 2,\n                min: -top + opts.thumbmargin * 10,\n                max: -top + measures.h - height - opts.thumbmargin * 10\n            };\n\n            return opts.navdir === 'vertical' ? verticalBounds : horizontalBounds;\n        }\n\n        function slideThumbBorder(time) {\n            var navFrameData = activeFrame[navFrameKey].data();\n            slide($thumbBorder, {\n                time: time * 1.2,\n                pos: (opts.navdir === 'vertical' ? navFrameData.t : navFrameData.l),\n                width: navFrameData.w,\n                height: navFrameData.h,\n                direction: opts.navdir\n            });\n        }\n\n        function slideNavShaft(options) {\n            var $guessNavFrame = data[options.guessIndex][navFrameKey],\n                typeOfAnimation = opts.navtype;\n\n            var overflowFLAG,\n                time,\n                minMax,\n                boundTop,\n                boundLeft,\n                l,\n                pos,\n                x;\n\n            if ($guessNavFrame) {\n                if (typeOfAnimation === 'thumbs') {\n                    overflowFLAG = navShaftTouchTail.min !== navShaftTouchTail.max;\n                    minMax = options.minMax || overflowFLAG && getNavFrameBounds(activeFrame[navFrameKey]);\n                    boundTop = overflowFLAG && (options.keep && slideNavShaft.t ? slideNavShaft.l : minMaxLimit((options.coo || measures.nw / 2) - getNavFrameBounds($guessNavFrame).c, minMax.min, minMax.max));\n                    boundLeft = overflowFLAG && (options.keep && slideNavShaft.l ? slideNavShaft.l : minMaxLimit((options.coo || measures.nw / 2) - getNavFrameBounds($guessNavFrame).c, minMax.min, minMax.max));\n                    l = (opts.navdir === 'vertical' ? boundTop : boundLeft);\n                    pos = overflowFLAG && minMaxLimit(l, navShaftTouchTail.min, navShaftTouchTail.max) || 0;\n                    time = options.time * 1.1;\n                    slide($navShaft, {\n                        time: time,\n                        pos: pos,\n                        direction: opts.navdir,\n                        onEnd: function () {\n                            thumbsDraw(pos, true);\n                            thumbArrUpdate();\n                        }\n                    });\n\n                    setShadow($nav, findShadowEdge(pos, navShaftTouchTail.min, navShaftTouchTail.max, opts.navdir));\n                    slideNavShaft.l = l;\n                } else {\n                    x = readPosition($navShaft, opts.navdir);\n                    time = options.time * 1.11;\n\n                    pos = validateSlidePos(opts, navShaftTouchTail, options.guessIndex, x, $guessNavFrame, $navWrap, opts.navdir);\n\n                    slide($navShaft, {\n                        time: time,\n                        pos: pos,\n                        direction: opts.navdir,\n                        onEnd: function () {\n                            thumbsDraw(pos, true);\n                            thumbArrUpdate();\n                        }\n                    });\n                    setShadow($nav, findShadowEdge(pos, navShaftTouchTail.min, navShaftTouchTail.max, opts.navdir));\n                }\n            }\n        }\n\n        function navUpdate() {\n            deactivateFrames(navFrameKey);\n            toDeactivate[navFrameKey].push(activeFrame[navFrameKey].addClass(activeClass).attr('data-active', true));\n        }\n\n        function deactivateFrames(key) {\n            var _toDeactivate = toDeactivate[key];\n\n            while (_toDeactivate.length) {\n                _toDeactivate.shift().removeClass(activeClass).attr('data-active', false);\n            }\n        }\n\n        function detachFrames(key) {\n            var _toDetach = toDetach[key];\n\n            $.each(activeIndexes, function (i, index) {\n                delete _toDetach[normalizeIndex(index)];\n            });\n\n            $.each(_toDetach, function (index, $frame) {\n                delete _toDetach[index];\n                $frame.detach();\n            });\n        }\n\n        function stageShaftReposition(skipOnEnd) {\n\n            repositionIndex = dirtyIndex = activeIndex;\n\n            var $frame = activeFrame[STAGE_FRAME_KEY];\n\n            if ($frame) {\n                deactivateFrames(STAGE_FRAME_KEY);\n                toDeactivate[STAGE_FRAME_KEY].push($frame.addClass(activeClass).attr('data-active', true));\n\n                if ($frame.hasClass(stageFrameClass)) {\n                    $frame.attr('aria-hidden', 'false');\n                }\n\n                skipOnEnd || that.showStage.onEnd(true);\n                stop($stageShaft, 0, true);\n\n                detachFrames(STAGE_FRAME_KEY);\n                stageFramePosition(activeIndexes);\n                setStageShaftMinmaxAndSnap();\n                setNavShaftMinMax();\n                addEnterUp($stageShaft[0], function () {\n                    if (!$fotorama.hasClass(fullscreenClass)) {\n                        that.requestFullScreen();\n                        $(fullscreenIcon).trigger('focus');\n                    }\n                });\n            }\n        }\n\n        function extendMeasures(options, measuresArray) {\n            if (!options) return;\n\n            $.each(measuresArray, function (i, measures) {\n                if (!measures) return;\n\n                $.extend(measures, {\n                    width: options.width || measures.width,\n                    height: options.height,\n                    minwidth: options.minwidth,\n                    maxwidth: options.maxwidth,\n                    minheight: options.minheight,\n                    maxheight: options.maxheight,\n                    ratio: getRatio(options.ratio)\n                })\n            });\n        }\n\n        function triggerEvent(event, extra) {\n            $fotorama.trigger(_fotoramaClass + ':' + event, [that, extra]);\n        }\n\n        function onTouchStart() {\n            clearTimeout(onTouchEnd.t);\n            touchedFLAG = 1;\n\n            if (opts.stopautoplayontouch) {\n                that.stopAutoplay();\n            } else {\n                pausedAutoplayFLAG = true;\n            }\n        }\n\n        function onTouchEnd() {\n            if (!touchedFLAG) return;\n            if (!opts.stopautoplayontouch) {\n                releaseAutoplay();\n                changeAutoplay();\n            }\n\n            onTouchEnd.t = setTimeout(function () {\n                touchedFLAG = 0;\n            }, TRANSITION_DURATION + TOUCH_TIMEOUT);\n        }\n\n        function releaseAutoplay() {\n            pausedAutoplayFLAG = !!($videoPlaying || stoppedAutoplayFLAG);\n        }\n\n        function changeAutoplay() {\n\n            clearTimeout(changeAutoplay.t);\n            waitFor.stop(changeAutoplay.w);\n\n            if (!opts.autoplay || pausedAutoplayFLAG) {\n                if (that.autoplay) {\n                    that.autoplay = false;\n                    triggerEvent('stopautoplay');\n                }\n\n                return;\n            }\n\n            if (!that.autoplay) {\n                that.autoplay = true;\n                triggerEvent('startautoplay');\n            }\n\n            var _activeIndex = activeIndex;\n\n\n            var frameData = activeFrame[STAGE_FRAME_KEY].data();\n            changeAutoplay.w = waitFor(function () {\n                return frameData.state || _activeIndex !== activeIndex;\n            }, function () {\n                changeAutoplay.t = setTimeout(function () {\n\n                    if (pausedAutoplayFLAG || _activeIndex !== activeIndex) return;\n\n                    var _nextAutoplayIndex = nextAutoplayIndex,\n                        nextFrameData = data[_nextAutoplayIndex][STAGE_FRAME_KEY].data();\n\n                    changeAutoplay.w = waitFor(function () {\n\n                        return nextFrameData.state || _nextAutoplayIndex !== nextAutoplayIndex;\n                    }, function () {\n                        if (pausedAutoplayFLAG || _nextAutoplayIndex !== nextAutoplayIndex) return;\n                        that.show(o_loop ? getDirectionSign(!o_rtl) : nextAutoplayIndex);\n                    });\n                }, opts.autoplay);\n            });\n\n        }\n\n        that.startAutoplay = function (interval) {\n            if (that.autoplay) return this;\n            pausedAutoplayFLAG = stoppedAutoplayFLAG = false;\n            setAutoplayInterval(interval || opts.autoplay);\n            changeAutoplay();\n\n            return this;\n        };\n\n        that.stopAutoplay = function () {\n            if (that.autoplay) {\n                pausedAutoplayFLAG = stoppedAutoplayFLAG = true;\n                changeAutoplay();\n            }\n            return this;\n        };\n\n        that.showSlide = function (slideDir) {\n            var currentPosition = readPosition($navShaft, opts.navdir),\n                pos,\n                time = 500 * 1.1,\n                size = opts.navdir === 'horizontal' ? opts.thumbwidth : opts.thumbheight,\n                onEnd = function () {\n                    thumbArrUpdate();\n                };\n            if (slideDir === 'next') {\n                pos = currentPosition - (size + opts.margin) * thumbsPerSlide;\n            }\n            if (slideDir === 'prev') {\n                pos = currentPosition + (size + opts.margin) * thumbsPerSlide;\n            }\n            pos = validateRestrictions(pos, navShaftTouchTail);\n            thumbsDraw(pos, true);\n            slide($navShaft, {\n                time: time,\n                pos: pos,\n                direction: opts.navdir,\n                onEnd: onEnd\n            });\n        };\n\n        that.showWhileLongPress = function (options) {\n            if (that.longPress.singlePressInProgress)\n            {\n                return;\n            }\n\n            var index = calcActiveIndex(options);\n            calcGlobalIndexes(index);\n            var time = calcTime(options)/50;\n            var _activeFrame = activeFrame;\n            that.activeFrame = activeFrame = data[activeIndex];\n            var silent = _activeFrame === activeFrame && !options.user;\n\n            that.showNav(silent, options, time);\n\n            return this;\n        };\n\n        that.showEndLongPress = function (options) {\n            if (that.longPress.singlePressInProgress)\n            {\n                return;\n            }\n\n            var index = calcActiveIndex(options);\n            calcGlobalIndexes(index);\n            var time = calcTime(options)/50;\n            var _activeFrame = activeFrame;\n            that.activeFrame = activeFrame = data[activeIndex];\n\n            var silent = _activeFrame === activeFrame && !options.user;\n\n            that.showStage(silent, options, time);\n\n            showedFLAG = typeof lastActiveIndex !== 'undefined' && lastActiveIndex !== activeIndex;\n            lastActiveIndex = activeIndex;\n            return this;\n        };\n\n        function calcActiveIndex (options) {\n            var index;\n\n            if (typeof options !== 'object') {\n                index = options;\n                options = {};\n            } else {\n                index = options.index;\n            }\n\n            index = index === '>' ? dirtyIndex + 1 : index === '<' ? dirtyIndex - 1 : index === '<<' ? 0 : index === '>>' ? size - 1 : index;\n            index = isNaN(index) ? undefined : index;\n            index = typeof index === 'undefined' ? activeIndex || 0 : index;\n\n            return index;\n        }\n\n        function calcGlobalIndexes (index) {\n            that.activeIndex = activeIndex = edgeIndex(index);\n            prevIndex = getPrevIndex(activeIndex);\n            nextIndex = getNextIndex(activeIndex);\n            nextAutoplayIndex = normalizeIndex(activeIndex + (o_rtl ? -1 : 1));\n            activeIndexes = [activeIndex, prevIndex, nextIndex];\n\n            dirtyIndex = o_loop ? index : activeIndex;\n        }\n\n        function calcTime (options) {\n            var diffIndex = Math.abs(lastActiveIndex - dirtyIndex),\n                time = getNumber(options.time, function () {\n                    return Math.min(o_transitionDuration * (1 + (diffIndex - 1) / 12), o_transitionDuration * 2);\n                });\n\n            if (options.slow) {\n                time *= 10;\n            }\n\n            return time;\n        }\n\n        that.showStage = function (silent, options, time) {\n            unloadVideo($videoPlaying, activeFrame.i !== data[normalizeIndex(repositionIndex)].i);\n            frameDraw(activeIndexes, 'stage');\n            stageFramePosition(SLOW ? [dirtyIndex] : [dirtyIndex, getPrevIndex(dirtyIndex), getNextIndex(dirtyIndex)]);\n            updateTouchTails('go', true);\n\n            silent || triggerEvent('show', {\n                user: options.user,\n                time: time\n            });\n\n            pausedAutoplayFLAG = true;\n\n            var overPos = options.overPos;\n            var onEnd = that.showStage.onEnd = function (skipReposition) {\n                if (onEnd.ok) return;\n                onEnd.ok = true;\n\n                skipReposition || stageShaftReposition(true);\n\n                if (!silent) {\n                    triggerEvent('showend', {\n                        user: options.user\n                    });\n                }\n\n                if (!skipReposition && o_transition && o_transition !== opts.transition) {\n                    that.setOptions({transition: o_transition});\n                    o_transition = false;\n                    return;\n                }\n\n                updateFotoramaState();\n                loadImg(activeIndexes, 'stage');\n\n                updateTouchTails('go', false);\n                stageWheelUpdate();\n\n                stageCursor();\n                releaseAutoplay();\n                changeAutoplay();\n            };\n\n            if (!o_fade) {\n                slide($stageShaft, {\n                    pos: -getPosByIndex(dirtyIndex, measures.w, opts.margin, repositionIndex),\n                    overPos: overPos,\n                    time: time,\n                    onEnd: onEnd\n                });\n            } else {\n                var $activeFrame = activeFrame[STAGE_FRAME_KEY],\n                    $prevActiveFrame = data[lastActiveIndex] && activeIndex !== lastActiveIndex ? data[lastActiveIndex][STAGE_FRAME_KEY] : null;\n\n                fade($activeFrame, $prevActiveFrame, $stageFrame, {\n                    time: time,\n                    method: opts.transition,\n                    onEnd: onEnd\n                }, fadeStack);\n            }\n\n            arrsUpdate();\n        };\n\n        that.showNav = function(silent, options, time){\n            thumbArrUpdate();\n            if (o_nav) {\n                navUpdate();\n\n                var guessIndex = limitIndex(activeIndex + minMaxLimit(dirtyIndex - lastActiveIndex, -1, 1));\n                slideNavShaft({\n                    time: time,\n                    coo: guessIndex !== activeIndex && options.coo,\n                    guessIndex: typeof options.coo !== 'undefined' ? guessIndex : activeIndex,\n                    keep: silent\n                });\n                if (o_navThumbs) slideThumbBorder(time);\n            }\n        };\n\n        that.show = function (options) {\n            that.longPress.singlePressInProgress = true;\n\n            var index = calcActiveIndex(options);\n            calcGlobalIndexes(index);\n            var time = calcTime(options);\n            var _activeFrame = activeFrame;\n            that.activeFrame = activeFrame = data[activeIndex];\n\n            var silent = _activeFrame === activeFrame && !options.user;\n\n            that.showStage(silent, options, time);\n            that.showNav(silent, options, time);\n\n            showedFLAG = typeof lastActiveIndex !== 'undefined' && lastActiveIndex !== activeIndex;\n            lastActiveIndex = activeIndex;\n            that.longPress.singlePressInProgress = false;\n\n            return this;\n        };\n\n        that.requestFullScreen = function () {\n            if (o_allowFullScreen && !that.fullScreen) {\n\n                //check that this is not video\n                var isVideo = $((that.activeFrame || {}).$stageFrame || {}).hasClass('fotorama-video-container');\n                if(isVideo) {\n                    return;\n                }\n\n                scrollTop = $WINDOW.scrollTop();\n                scrollLeft = $WINDOW.scrollLeft();\n\n                lockScroll($WINDOW);\n\n                updateTouchTails('x', true);\n\n                measuresStash = $.extend({}, measures);\n\n                $fotorama\n                    .addClass(fullscreenClass)\n                    .appendTo($BODY.addClass(_fullscreenClass));\n\n                $HTML.addClass(_fullscreenClass);\n\n                unloadVideo($videoPlaying, true, true);\n\n                that.fullScreen = true;\n\n                if (o_nativeFullScreen) {\n                    fullScreenApi.request(fotorama);\n                }\n\n                that.resize();\n                loadImg(activeIndexes, 'stage');\n                updateFotoramaState();\n\n                triggerEvent('fullscreenenter');\n            }\n\n            return this;\n        };\n\n        function cancelFullScreen() {\n            if (that.fullScreen) {\n                that.fullScreen = false;\n\n                if (FULLSCREEN) {\n                    fullScreenApi.cancel(fotorama);\n                }\n\n                $BODY.removeClass(_fullscreenClass);\n                $HTML.removeClass(_fullscreenClass);\n\n                $fotorama\n                    .removeClass(fullscreenClass)\n                    .insertAfter($anchor);\n\n                measures = $.extend({}, measuresStash);\n\n                unloadVideo($videoPlaying, true, true);\n\n                updateTouchTails('x', false);\n\n                that.resize();\n                loadImg(activeIndexes, 'stage');\n\n                lockScroll($WINDOW, scrollLeft, scrollTop);\n\n                triggerEvent('fullscreenexit');\n            }\n        }\n\n        that.cancelFullScreen = function () {\n            if (o_nativeFullScreen && fullScreenApi.is()) {\n                fullScreenApi.cancel(document);\n            } else {\n                cancelFullScreen();\n            }\n\n            return this;\n        };\n\n        that.toggleFullScreen = function () {\n            return that[(that.fullScreen ? 'cancel' : 'request') + 'FullScreen']();\n        };\n\n        addEvent(document, fullScreenApi.event, function () {\n            if (data && !fullScreenApi.is() && !$videoPlaying) {\n                cancelFullScreen();\n            }\n        });\n\n        that.resize = function (options) {\n            if (!data) return this;\n\n            var time = arguments[1] || 0,\n                setFLAG = arguments[2];\n\n            thumbsPerSlide = getThumbsInSlide($wrap, opts);\n            extendMeasures(!that.fullScreen ? optionsToLowerCase(options) : {\n                width: $(window).width(),\n                maxwidth: null,\n                minwidth: null,\n                height: $(window).height(),\n                maxheight: null,\n                minheight: null\n            }, [measures, setFLAG || that.fullScreen || opts]);\n\n            var width = measures.width,\n                height = measures.height,\n                ratio = measures.ratio,\n                windowHeight = $WINDOW.height() - (o_nav ? $nav.height() : 0);\n\n            if (measureIsValid(width)) {\n                $wrap.css({width: ''});\n                $wrap.css({height: ''});\n                $stage.css({width: ''});\n                $stage.css({height: ''});\n                $stage.css({'line-height': ''});\n                $stageShaft.css({width: ''});\n                $stageShaft.css({height: ''});\n                $nav.css({width: ''});\n                $nav.css({height: ''});\n                $wrap.css({minWidth: measures.minwidth || 0, maxWidth: measures.maxwidth || MAX_WIDTH});\n\n                width = measures.W = measures.w = $wrap.width();\n                measures.nw = o_nav && numberFromWhatever(opts.navwidth, width) || width;\n\n                $stageShaft.css({width: measures.w, marginLeft: (measures.W - measures.w) / 2});\n\n                height = numberFromWhatever(height, windowHeight);\n\n                height = height || (ratio && width / ratio);\n\n                if (height) {\n                    width = Math.round(width);\n                    height = measures.h = Math.round(minMaxLimit(height, numberFromWhatever(measures.minheight, windowHeight), numberFromWhatever(measures.maxheight, windowHeight)));\n                    $stage.css({'width': width, 'height': height, 'line-height': height + 'px'});\n\n                    if (opts.navdir === 'vertical' && !that.fullscreen) {\n                        $nav.width(opts.thumbwidth + opts.thumbmargin * 2);\n                    }\n\n                    if (opts.navdir === 'horizontal' && !that.fullscreen) {\n                        $nav.height(opts.thumbheight + opts.thumbmargin * 2);\n                    }\n\n                    if (opts.navdir === 'vertical' && that.fullScreen) {\n                        $stage.css('height', $(window).height());\n                    }\n\n                    if (opts.navdir === 'horizontal' && that.fullScreen) {\n                        $stage.css('height', $(window).height() - (opts.thumbheight + opts.thumbmargin * 2));\n                    }\n\n                    if (o_nav) {\n                        switch (opts.navdir) {\n                            case 'vertical':\n                                $navWrap.removeClass(navShafthorizontalClass);\n                                $navWrap.removeClass(navShaftListClass);\n                                $navWrap.addClass(navShaftVerticalClass);\n                                $nav\n                                    .stop()\n                                    .animate({height: measures.h, width: opts.thumbwidth}, time);\n                                break;\n                            case 'list':\n                                $navWrap.removeClass(navShaftVerticalClass);\n                                $navWrap.removeClass(navShafthorizontalClass);\n                                $navWrap.addClass(navShaftListClass);\n                                break;\n                            default:\n                                $navWrap.removeClass(navShaftVerticalClass);\n                                $navWrap.removeClass(navShaftListClass);\n                                $navWrap.addClass(navShafthorizontalClass);\n                                $nav\n                                    .stop()\n                                    .animate({width: measures.nw}, time);\n                                break;\n                        }\n\n                        stageShaftReposition();\n                        slideNavShaft({guessIndex: activeIndex, time: time, keep: true});\n                        if (o_navThumbs && frameAppend.nav) slideThumbBorder(time);\n                    }\n\n                    measuresSetFLAG = setFLAG || true;\n\n                    ready.ok = true;\n                    ready();\n                }\n            }\n\n            stageLeft = $stage.offset().left;\n            setStagePosition();\n\n            return this;\n        };\n\n        that.setOptions = function (options) {\n            $.extend(opts, options);\n            reset();\n            return this;\n        };\n\n        that.shuffle = function () {\n            data && shuffle(data) && reset();\n            return this;\n        };\n\n        function setShadow($el, edge) {\n            if (o_shadows) {\n                $el.removeClass(shadowsLeftClass + ' ' + shadowsRightClass);\n                $el.removeClass(shadowsTopClass + ' ' + shadowsBottomClass);\n                edge && !$videoPlaying && $el.addClass(edge.replace(/^|\\s/g, ' ' + shadowsClass + '--'));\n            }\n        }\n\n        that.longPress = {\n            threshold: 1,\n            count: 0,\n            thumbSlideTime: 20,\n            progress: function(){\n                if (!this.inProgress) {\n                    this.count++;\n                    this.inProgress = this.count > this.threshold;\n                }\n            },\n            end: function(){\n                if(this.inProgress) {\n                    this.isEnded = true\n                }\n            },\n            reset: function(){\n                this.count = 0;\n                this.inProgress = false;\n                this.isEnded = false;\n            }\n        };\n\n        that.destroy = function () {\n            that.cancelFullScreen();\n            that.stopAutoplay();\n\n            data = that.data = null;\n\n            appendElements();\n\n            activeIndexes = [];\n            detachFrames(STAGE_FRAME_KEY);\n\n            reset.ok = false;\n\n            return this;\n        };\n\n        /**\n         *\n         * @returns {jQuery.Fotorama}\n         */\n        that.playVideo = function () {\n            var dataFrame = activeFrame,\n                video = dataFrame.video,\n                _activeIndex = activeIndex;\n\n            if (typeof video === 'object' && dataFrame.videoReady) {\n                o_nativeFullScreen && that.fullScreen && that.cancelFullScreen();\n\n                waitFor(function () {\n                    return !fullScreenApi.is() || _activeIndex !== activeIndex;\n                }, function () {\n                    if (_activeIndex === activeIndex) {\n                        dataFrame.$video = dataFrame.$video || $(div(videoClass)).append(createVideoFrame(video));\n                        dataFrame.$video.appendTo(dataFrame[STAGE_FRAME_KEY]);\n\n                        $wrap.addClass(wrapVideoClass);\n                        $videoPlaying = dataFrame.$video;\n\n                        stageNoMove();\n\n                        $arrs.blur();\n                        $fullscreenIcon.blur();\n\n                        triggerEvent('loadvideo');\n                    }\n                });\n            }\n\n            return this;\n        };\n\n        that.stopVideo = function () {\n            unloadVideo($videoPlaying, true, true);\n            return this;\n        };\n\n        function unloadVideo($video, unloadActiveFLAG, releaseAutoplayFLAG) {\n            if (unloadActiveFLAG) {\n                $wrap.removeClass(wrapVideoClass);\n                $videoPlaying = false;\n\n                stageNoMove();\n            }\n\n            if ($video && $video !== $videoPlaying) {\n                $video.remove();\n                triggerEvent('unloadvideo');\n            }\n\n            if (releaseAutoplayFLAG) {\n                releaseAutoplay();\n                changeAutoplay();\n            }\n        }\n\n        function toggleControlsClass(FLAG) {\n            $wrap.toggleClass(wrapNoControlsClass, FLAG);\n        }\n\n        function stageCursor(e) {\n            if (stageShaftTouchTail.flow) return;\n\n            var x = e ? e.pageX : stageCursor.x,\n                pointerFLAG = x && !disableDirrection(getDirection(x)) && opts.click;\n\n            if (stageCursor.p !== pointerFLAG\n                && $stage.toggleClass(pointerClass, pointerFLAG)) {\n                stageCursor.p = pointerFLAG;\n                stageCursor.x = x;\n            }\n        }\n\n        $stage.on('mousemove', stageCursor);\n\n        function clickToShow(showOptions) {\n            clearTimeout(clickToShow.t);\n\n            if (opts.clicktransition && opts.clicktransition !== opts.transition) {\n                setTimeout(function () {\n                    var _o_transition = opts.transition;\n\n                    that.setOptions({transition: opts.clicktransition});\n\n                    // now safe to pass base transition to o_transition, so that.show will restor it\n                    o_transition = _o_transition;\n                    // this timeout is here to prevent jerking in some browsers\n                    clickToShow.t = setTimeout(function () {\n                        that.show(showOptions);\n                    }, 10);\n                }, 0);\n            } else {\n                that.show(showOptions);\n            }\n        }\n\n        function onStageTap(e, toggleControlsFLAG) {\n            var target = e.target,\n                $target = $(target);\n            if ($target.hasClass(videoPlayClass)) {\n                that.playVideo();\n            } else if (target === fullscreenIcon) {\n                that.toggleFullScreen();\n            } else if ($videoPlaying) {\n                target === videoClose && unloadVideo($videoPlaying, true, true);\n            } else {\n                if (toggleControlsFLAG) {\n                    toggleControlsClass();\n                } else if (opts.click) {\n\n                    clickToShow({\n                        index: e.shiftKey || getDirectionSign(getDirection(e._x)),\n                        slow: e.altKey,\n                        user: true\n                    });\n                }\n            }\n        }\n\n        function updateTouchTails(key, value) {\n            stageShaftTouchTail[key] = navShaftTouchTail[key] = value;\n        }\n\n        stageShaftTouchTail = moveOnTouch($stageShaft, {\n            onStart: onTouchStart,\n            onMove: function (e, result) {\n                setShadow($stage, result.edge);\n            },\n            onTouchEnd: onTouchEnd,\n            onEnd: function (result) {\n                var toggleControlsFLAG;\n\n                setShadow($stage);\n                toggleControlsFLAG = (MS_POINTER && !hoverFLAG || result.touch) &&\n                    opts.arrows && opts.arrows !== 'always';\n\n                if ((result.moved || (toggleControlsFLAG && result.pos !== result.newPos && !result.control)) && result.$target[0] !== $fullscreenIcon[0]) {\n                    var index = getIndexByPos(result.newPos, measures.w, opts.margin, repositionIndex);\n\n                    that.show({\n                        index: index,\n                        time: o_fade ? o_transitionDuration : result.time,\n                        overPos: result.overPos,\n                        user: true\n                    });\n                } else if (!result.aborted && !result.control) {\n                    onStageTap(result.startEvent, toggleControlsFLAG);\n                }\n            },\n            timeLow: 1,\n            timeHigh: 1,\n            friction: 2,\n            select: '.' + selectClass + ', .' + selectClass + ' *',\n            $wrap: $stage,\n            direction: 'horizontal'\n\n        });\n\n        navShaftTouchTail = moveOnTouch($navShaft, {\n            onStart: onTouchStart,\n            onMove: function (e, result) {\n                setShadow($nav, result.edge);\n            },\n            onTouchEnd: onTouchEnd,\n            onEnd: function (result) {\n\n                function onEnd() {\n                    slideNavShaft.l = result.newPos;\n                    releaseAutoplay();\n                    changeAutoplay();\n                    thumbsDraw(result.newPos, true);\n                    thumbArrUpdate();\n                }\n\n                if (!result.moved) {\n                    var target = result.$target.closest('.' + navFrameClass, $navShaft)[0];\n                    target && onNavFrameClick.call(target, result.startEvent);\n                } else if (result.pos !== result.newPos) {\n                    pausedAutoplayFLAG = true;\n                    slide($navShaft, {\n                        time: result.time,\n                        pos: result.newPos,\n                        overPos: result.overPos,\n                        direction: opts.navdir,\n                        onEnd: onEnd\n                    });\n                    thumbsDraw(result.newPos);\n                    o_shadows && setShadow($nav, findShadowEdge(result.newPos, navShaftTouchTail.min, navShaftTouchTail.max, result.dir));\n                } else {\n                    onEnd();\n                }\n            },\n            timeLow: .5,\n            timeHigh: 2,\n            friction: 5,\n            $wrap: $nav,\n            direction: opts.navdir\n        });\n\n        stageWheelTail = wheel($stage, {\n            shift: true,\n            onEnd: function (e, direction) {\n                onTouchStart();\n                onTouchEnd();\n                that.show({index: direction, slow: e.altKey})\n            }\n        });\n\n        navWheelTail = wheel($nav, {\n            onEnd: function (e, direction) {\n                onTouchStart();\n                onTouchEnd();\n                var newPos = stop($navShaft) + direction * .25;\n                $navShaft.css(getTranslate(minMaxLimit(newPos, navShaftTouchTail.min, navShaftTouchTail.max), opts.navdir));\n                o_shadows && setShadow($nav, findShadowEdge(newPos, navShaftTouchTail.min, navShaftTouchTail.max, opts.navdir));\n                navWheelTail.prevent = {'<': newPos >= navShaftTouchTail.max, '>': newPos <= navShaftTouchTail.min};\n                clearTimeout(navWheelTail.t);\n                navWheelTail.t = setTimeout(function () {\n                    slideNavShaft.l = newPos;\n                    thumbsDraw(newPos, true)\n                }, TOUCH_TIMEOUT);\n                thumbsDraw(newPos);\n            }\n        });\n\n        $wrap.hover(\n            function () {\n                setTimeout(function () {\n                    if (touchedFLAG) return;\n                    toggleControlsClass(!(hoverFLAG = true));\n                }, 0);\n            },\n            function () {\n                if (!hoverFLAG) return;\n                toggleControlsClass(!(hoverFLAG = false));\n            }\n        );\n\n        function onNavFrameClick(e) {\n            var index = $(this).data().eq;\n\n            if (opts.navtype === 'thumbs') {\n                clickToShow({index: index, slow: e.altKey, user: true, coo: e._x - $nav.offset().left});\n            } else {\n                clickToShow({index: index, slow: e.altKey, user: true});\n            }\n        }\n\n        function onArrClick(e) {\n            clickToShow({index: $arrs.index(this) ? '>' : '<', slow: e.altKey, user: true});\n        }\n\n        smartClick($arrs, function (e) {\n            stopEvent(e);\n            onArrClick.call(this, e);\n        }, {\n            onStart: function () {\n                onTouchStart();\n                stageShaftTouchTail.control = true;\n            },\n            onTouchEnd: onTouchEnd\n        });\n\n        smartClick($thumbArrLeft, function (e) {\n            stopEvent(e);\n            if (opts.navtype === 'thumbs') {\n\n                that.show('<');\n            } else {\n                that.showSlide('prev')\n            }\n        });\n\n        smartClick($thumbArrRight, function (e) {\n            stopEvent(e);\n            if (opts.navtype === 'thumbs') {\n                that.show('>');\n            } else {\n                that.showSlide('next')\n            }\n\n        });\n\n\n        function addFocusOnControls(el) {\n            addFocus(el, function () {\n                setTimeout(function () {\n                    lockScroll($stage);\n                }, 0);\n                toggleControlsClass(false);\n            });\n        }\n\n        $arrs.each(function () {\n            addEnterUp(this, function (e) {\n                onArrClick.call(this, e);\n            });\n            addFocusOnControls(this);\n        });\n\n        addEnterUp(fullscreenIcon, function () {\n            that.toggleFullScreen();\n            $(fullscreenIcon).trigger('focus');\n        });\n        addFocusOnControls(fullscreenIcon);\n\n        function reset() {\n            setData();\n            setOptions();\n\n            if (!reset.i) {\n                reset.i = true;\n                // Only once\n                var _startindex = opts.startindex;\n                activeIndex = repositionIndex = dirtyIndex = lastActiveIndex = startIndex = edgeIndex(_startindex) || 0;\n                /*(o_rtl ? size - 1 : 0)*///;\n            }\n\n            if (size) {\n                if (changeToRtl()) return;\n\n                if ($videoPlaying) {\n                    unloadVideo($videoPlaying, true);\n                }\n\n                activeIndexes = [];\n                detachFrames(STAGE_FRAME_KEY);\n\n                reset.ok = true;\n\n                that.show({index: activeIndex, time: 0});\n                that.resize();\n            } else {\n                that.destroy();\n            }\n        }\n\n        function changeToRtl() {\n\n            if (!changeToRtl.f === o_rtl) {\n                changeToRtl.f = o_rtl;\n                activeIndex = size - 1 - activeIndex;\n                that.reverse();\n\n                return true;\n            }\n        }\n\n        $.each('load push pop shift unshift reverse sort splice'.split(' '), function (i, method) {\n            that[method] = function () {\n                data = data || [];\n                if (method !== 'load') {\n                    Array.prototype[method].apply(data, arguments);\n                } else if (arguments[0] && typeof arguments[0] === 'object' && arguments[0].length) {\n                    data = clone(arguments[0]);\n                }\n                reset();\n                return that;\n            }\n        });\n\n        function ready() {\n            if (ready.ok) {\n                ready.ok = false;\n                triggerEvent('ready');\n            }\n        }\n\n        reset();\n    };\n    $.fn.fotorama = function (opts) {\n        return this.each(function () {\n            var that = this,\n                $fotorama = $(this),\n                fotoramaData = $fotorama.data(),\n                fotorama = fotoramaData.fotorama;\n\n            if (!fotorama) {\n                waitFor(function () {\n                    return !isHidden(that);\n                }, function () {\n                    fotoramaData.urtext = $fotorama.html();\n                    new $.Fotorama($fotorama,\n                        $.extend(\n                            {},\n                            OPTIONS,\n                            window.fotoramaDefaults,\n                            opts,\n                            fotoramaData\n                        )\n                    );\n                });\n            } else {\n                fotorama.setOptions(opts, true);\n            }\n        });\n    };\n    $.Fotorama.instances = [];\n\n    function calculateIndexes() {\n        $.each($.Fotorama.instances, function (index, instance) {\n            instance.index = index;\n        });\n    }\n\n    function addInstance(instance) {\n        $.Fotorama.instances.push(instance);\n        calculateIndexes();\n    }\n\n    function hideInstance(instance) {\n        $.Fotorama.instances.splice(instance.index, 1);\n        calculateIndexes();\n    }\n\n    $.Fotorama.cache = {};\n    $.Fotorama.measures = {};\n    $ = $ || {};\n    $.Fotorama = $.Fotorama || {};\n    $.Fotorama.jst = $.Fotorama.jst || {};\n\n    $.Fotorama.jst.dots = function (v) {\n        var __t, __p = '', __e = _.escape;\n        __p += '<div class=\"fotorama__nav__frame fotorama__nav__frame--dot\" tabindex=\"0\" role=\"button\" data-gallery-role=\"nav-frame\" data-nav-type=\"thumb\" aria-label>\\r\\n    <div class=\"fotorama__dot\"></div>\\r\\n</div>';\n        return __p\n    };\n\n    $.Fotorama.jst.frameCaption = function (v) {\n        var __t, __p = '', __e = _.escape;\n        __p += '<div class=\"fotorama__caption\" aria-hidden=\"true\">\\r\\n    <div class=\"fotorama__caption__wrap\" id=\"' +\n            ((__t = ( v.labelledby )) == null ? '' : __t) +\n            '\">' +\n            ((__t = ( v.caption )) == null ? '' : __t) +\n            '</div>\\r\\n</div>\\r\\n';\n        return __p\n    };\n\n    $.Fotorama.jst.style = function (v) {\n        var __t, __p = '', __e = _.escape;\n        __p += '.fotorama' +\n            ((__t = ( v.s )) == null ? '' : __t) +\n            ' .fotorama__nav--thumbs .fotorama__nav__frame{\\r\\npadding:' +\n            ((__t = ( v.m )) == null ? '' : __t) +\n            'px;\\r\\nheight:' +\n            ((__t = ( v.h )) == null ? '' : __t) +\n            'px}\\r\\n.fotorama' +\n            ((__t = ( v.s )) == null ? '' : __t) +\n            ' .fotorama__thumb-border{\\r\\nheight:' +\n            ((__t = ( v.h )) == null ? '' : __t) +\n            'px;\\r\\nborder-width:' +\n            ((__t = ( v.b )) == null ? '' : __t) +\n            'px;\\r\\nmargin-top:' +\n            ((__t = ( v.m )) == null ? '' : __t) +\n            'px}';\n        return __p\n    };\n\n    $.Fotorama.jst.thumb = function (v) {\n        var __t, __p = '', __e = _.escape;\n        __p += '<div class=\"fotorama__nav__frame fotorama__nav__frame--thumb\" tabindex=\"0\" role=\"button\" data-gallery-role=\"nav-frame\" data-nav-type=\"thumb\" aria-label>\\r\\n    <div class=\"fotorama__thumb\">\\r\\n    </div>\\r\\n</div>';\n        return __p\n    };\n})(window, document, location, typeof jQuery !== 'undefined' && jQuery);\n","fotorama/fotorama.min.js":"/*!\n * Fotorama 4.6.4 | http://fotorama.io/license/\n */\nfotoramaVersion=\"4.6.4\",function(t,e,n,o,i){\"use strict\";function r(t){var e=\"bez_\"+o.makeArray(arguments).join(\"_\").replace(\".\",\"p\");if(\"function\"!=typeof o.easing[e]){var n=function(t,e){var n=[null,null],o=[null,null],i=[null,null],r=function(r,a){return i[a]=3*t[a],o[a]=3*(e[a]-t[a])-i[a],n[a]=1-i[a]-o[a],r*(i[a]+r*(o[a]+r*n[a]))},a=function(t){return i[0]+t*(2*o[0]+3*n[0]*t)},s=function(t){for(var e,n=t,o=0;++o<14&&(e=r(n,0)-t,!(Math.abs(e)<.001));)n-=e/a(n);return n};return function(t){return r(s(t),1)}};o.easing[e]=function(e,o,i,r,a){return r*n([t[0],t[1]],[t[2],t[3]])(o/a)+i}}return e}function a(){}function s(t,e,n){return Math.max(isNaN(e)?-1/0:e,Math.min(isNaN(n)?1/0:n,t))}function u(t,e){return t.match(/ma/)&&t.match(/-?\\d+(?!d)/g)[t.match(/3d/)?\"vertical\"===e?13:12:\"vertical\"===e?5:4]}function l(t,e){return On?+u(t.css(\"transform\"),e):+t.css(\"vertical\"===e?\"top\":\"left\").replace(\"px\",\"\")}function c(t,e){var n={};if(On)switch(e){case\"vertical\":n.transform=\"translate3d(0, \"+t+\"px,0)\";break;case\"list\":break;default:n.transform=\"translate3d(\"+t+\"px,0,0)\"}else\"vertical\"===e?n.top=t:n.left=t;return n}function d(t){return{\"transition-duration\":t+\"ms\"}}function f(t,e){return isNaN(t)?e:t}function h(t,e){return f(+String(t).replace(e||\"px\",\"\"))}function m(t){return/%$/.test(t)?h(t,\"%\"):i}function p(t,e){return f(m(t)/100*e,h(t))}function v(t){return(!isNaN(h(t))||!isNaN(h(t,\"%\")))&&t}function g(t,e,n,o){return(t-(o||0))*(e+(n||0))}function w(t,e,n,o){return-Math.round(t/(e+(n||0))-(o||0))}function y(t){var e=t.data();if(!e.tEnd){var n=t[0],o={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"oTransitionEnd otransitionend\",msTransition:\"MSTransitionEnd\",transition:\"transitionend\"};V(n,o[Tn.prefixed(\"transition\")],function(t){e.tProp&&t.propertyName.match(e.tProp)&&e.onEndFn()}),e.tEnd=!0}}function b(t,e,n,o){var i,r=t.data();r&&(r.onEndFn=function(){i||(i=!0,clearTimeout(r.tT),n())},r.tProp=e,clearTimeout(r.tT),r.tT=setTimeout(function(){r.onEndFn()},1.5*o),y(t))}function x(t,e){var n=t.navdir||\"horizontal\";if(t.length){var o=t.data();On?(t.css(d(0)),o.onEndFn=a,clearTimeout(o.tT)):t.stop();var i=_(e,function(){return l(t,n)});return t.css(c(i,n)),i}}function _(){for(var t,e=0,n=arguments.length;n>e&&(t=e?arguments[e]():arguments[e],\"number\"!=typeof t);e++);return t}function C(t,e){return Math.round(t+(e-t)/1.5)}function k(){return k.p=k.p||(\"https:\"===n.protocol?\"https://\":\"http://\"),k.p}function T(t){var n=e.createElement(\"a\");return n.href=t,n}function P(t,e){if(\"string\"!=typeof t)return t;t=T(t);var n,o;if(t.host.match(/youtube\\.com/)&&t.search){if(n=t.search.split(\"v=\")[1]){var i=n.indexOf(\"&\");-1!==i&&(n=n.substring(0,i)),o=\"youtube\"}}else t.host.match(/youtube\\.com|youtu\\.be/)?(n=t.pathname.replace(/^\\/(embed\\/|v\\/)?/,\"\").replace(/\\/.*/,\"\"),o=\"youtube\"):t.host.match(/vimeo\\.com/)&&(o=\"vimeo\",n=t.pathname.replace(/^\\/(video\\/)?/,\"\").replace(/\\/.*/,\"\"));return n&&o||!e||(n=t.href,o=\"custom\"),n?{id:n,type:o,s:t.search.replace(/^\\?/,\"\"),p:k()}:!1}function S(t,e,n){var i,r,a=t.video;return\"youtube\"===a.type?(r=k()+\"img.youtube.com/vi/\"+a.id+\"/default.jpg\",i=r.replace(/\\/default.jpg$/,\"/hqdefault.jpg\"),t.thumbsReady=!0):\"vimeo\"===a.type?o.ajax({url:k()+\"vimeo.com/api/v2/video/\"+a.id+\".json\",dataType:\"jsonp\",success:function(o){t.thumbsReady=!0,M(e,{img:o[0].thumbnail_large,thumb:o[0].thumbnail_small},t.i,n)}}):t.thumbsReady=!0,{img:i,thumb:r}}function M(t,e,n,i){for(var r=0,a=t.length;a>r;r++){var s=t[r];if(s.i===n&&s.thumbsReady){var u={videoReady:!0};u[to]=u[no]=u[eo]=!1,i.splice(r,1,o.extend({},s,u,e));break}}}function F(t){function e(t,e,i){var r=t.children(\"img\").eq(0),a=t.attr(\"href\"),s=t.attr(\"src\"),u=r.attr(\"src\"),l=e.video,c=i?P(a,l===!0):!1;c?a=!1:c=l,n(t,r,o.extend(e,{video:c,img:e.img||a||s||u,thumb:e.thumb||u||s||a}))}function n(t,e,n){var i=n.thumb&&n.img!==n.thumb,r=h(n.width||t.attr(\"width\")),a=h(n.height||t.attr(\"height\"));o.extend(n,{width:r,height:a,thumbratio:K(n.thumbratio||h(n.thumbwidth||e&&e.attr(\"width\")||i||r)/h(n.thumbheight||e&&e.attr(\"height\")||i||a))})}var i=[];return t.children().each(function(){var t=o(this),r=H(o.extend(t.data(),{id:t.attr(\"id\")}));if(t.is(\"a, img\"))e(t,r,!0);else{if(t.is(\":empty\"))return;n(t,null,o.extend(r,{html:this,_html:t.html()}))}i.push(r)}),i}function E(t){return 0===t.offsetWidth&&0===t.offsetHeight}function j(t){return!o.contains(e.documentElement,t)}function z(t,e,n,o){return z.i||(z.i=1,z.ii=[!0]),o=o||z.i,\"undefined\"==typeof z.ii[o]&&(z.ii[o]=!0),t()?e():z.ii[o]&&setTimeout(function(){z.ii[o]&&z(t,e,n,o)},n||100),z.i++}function N(t,e){var n=t.data(),o=n.measures;if(o&&(!n.l||n.l.W!==o.width||n.l.H!==o.height||n.l.r!==o.ratio||n.l.w!==e.w||n.l.h!==e.h)){var i=s(e.h,0,o.height),r=i*o.ratio;po.setRatio(t,r,i),n.l={W:o.width,H:o.height,r:o.ratio,w:e.w,h:e.h}}return!0}function $(t,e){var n=t[0];n.styleSheet?n.styleSheet.cssText=e:t.html(e)}function q(t,e,n,o){return e===n?!1:\"vertical\"===o?e>=t?\"top\":t>=n?\"bottom\":\"top bottom\":e>=t?\"left\":t>=n?\"right\":\"left right\"}function L(t,e,n){n=n||{},t.each(function(){var t,i=o(this),r=i.data();r.clickOn||(r.clickOn=!0,o.extend(oe(i,{onStart:function(e){t=e,(n.onStart||a).call(this,e)},onMove:n.onMove||a,onTouchEnd:n.onTouchEnd||a,onEnd:function(n){n.moved||e.call(this,t)}}),{noMove:!0}))})}function A(t,e){return'<div class=\"'+t+'\">'+(e||\"\")+\"</div>\"}function I(t){return\".\"+t}function O(t){var e='<iframe src=\"'+t.p+t.type+\".com/embed/\"+t.id+'\" frameborder=\"0\" allowfullscreen></iframe>';return e}function D(t){for(var e=t.length;e;){var n=Math.floor(Math.random()*e--),o=t[e];t[e]=t[n],t[n]=o}return t}function R(t){return\"[object Array]\"==Object.prototype.toString.call(t)&&o.map(t,function(t){return o.extend({},t)})}function W(t,e,n){t.scrollLeft(e||0).scrollTop(n||0)}function H(t){if(t){var e={};return o.each(t,function(t,n){e[t.toLowerCase()]=n}),e}}function K(t){if(t){var e=+t;return isNaN(e)?(e=t.split(\"/\"),+e[0]/+e[1]||i):e}}function V(t,e,n,o){e&&(t.addEventListener?t.addEventListener(e,n,!!o):t.attachEvent(\"on\"+e,n))}function B(t,e){return t>e.max?t=e.max:t<e.min&&(t=e.min),t}function Q(t,e,n,o,i,r,a){var s,u,l;return\"horizontal\"===a?(u=t.thumbwidth,l=r.width()):(u=t.thumbheight,l=r.height()),s=(u+t.margin)*(n+1)>=l-o?\"horizontal\"===a?-i.position().left:-i.position().top:(u+t.margin)*n<=Math.abs(o)?\"horizontal\"===a?-i.position().left+l-(u+t.margin):-i.position().top+l-(u+t.margin):o,s=B(s,e),s||0}function X(t){return!!t.getAttribute(\"disabled\")}function U(t){return{tabindex:-1*t+\"\",disabled:t}}function Y(t,e){V(t,\"keyup\",function(n){X(t)||13==n.keyCode&&e.call(t,n)})}function G(t,e){V(t,\"focus\",t.onfocusin=function(n){e.call(t,n)},!0)}function J(t,e){t.preventDefault?t.preventDefault():t.returnValue=!1,e&&t.stopPropagation&&t.stopPropagation()}function Z(t){return t?\">\":\"<\"}function te(t,e){var n=t.data(),i=Math.round(e.pos),r=function(){n&&n.sliding&&(n.sliding=!1),(e.onEnd||a)()};\"undefined\"!=typeof e.overPos&&e.overPos!==e.pos&&(i=e.overPos);var s=o.extend(c(i,e.direction),e.width&&{width:e.width},e.height&&{height:e.height});n&&n.sliding&&(n.sliding=!0),On?(t.css(o.extend(d(e.time),s)),e.time>10?b(t,\"transform\",r,e.time):r()):t.stop().animate(s,e.time,io,r)}function ee(t,e,n,i,r,s){var u=\"undefined\"!=typeof s;if(u||(r.push(arguments),Array.prototype.push.call(arguments,r.length),!(r.length>1))){t=t||o(t),e=e||o(e);var l=t[0],c=e[0],d=\"crossfade\"===i.method,f=function(){if(!f.done){f.done=!0;var t=(u||r.shift())&&r.shift();t&&ee.apply(this,t),(i.onEnd||a)(!!t)}},h=i.time/(s||1);n.removeClass(Ke+\" \"+He),t.stop().addClass(Ke),e.stop().addClass(He),d&&c&&t.fadeTo(0,0),t.fadeTo(d?h:0,1,d&&f),e.fadeTo(h,0,f),l&&d||c||f()}}function ne(t){var e=(t.touches||[])[0]||t;t._x=e.pageX,t._y=e.clientY,t._now=o.now()}function oe(t,n){function i(t){return f=o(t.target),b.checked=p=v=w=!1,c||b.flow||t.touches&&t.touches.length>1||t.which>1||lo&&lo.type!==t.type&&fo||(p=n.select&&f.is(n.select,y))?p:(m=\"touchstart\"===t.type,v=f.is(\"a, a *\",y),h=b.control,g=b.noMove||b.noSwipe||h?16:b.snap?0:4,ne(t),d=lo=t,co=t.type.replace(/down|start/,\"move\").replace(/Down/,\"Move\"),(n.onStart||a).call(y,t,{control:h,$target:f}),c=b.flow=!0,void((!m||b.go)&&J(t)))}function r(t){if(t.touches&&t.touches.length>1||Kn&&!t.isPrimary||co!==t.type||!c)return c&&s(),void(n.onTouchEnd||a)();ne(t);var e=Math.abs(t._x-d._x),o=Math.abs(t._y-d._y),i=e-o,r=(b.go||b.x||i>=0)&&!b.noSwipe,u=0>i;m&&!b.checked?(c=r)&&J(t):(J(t),(n.onMove||a).call(y,t,{touch:m})),!w&&Math.sqrt(Math.pow(e,2)+Math.pow(o,2))>g&&(w=!0),b.checked=b.checked||r||u}function s(t){(n.onTouchEnd||a)();var e=c;b.control=c=!1,e&&(b.flow=!1),!e||v&&!b.checked||(t&&J(t),fo=!0,clearTimeout(ho),ho=setTimeout(function(){fo=!1},1e3),(n.onEnd||a).call(y,{moved:w,$target:f,control:h,touch:m,startEvent:d,aborted:!t||\"MSPointerCancel\"===t.type}))}function u(){b.flow||setTimeout(function(){b.flow=!0},10)}function l(){b.flow&&setTimeout(function(){b.flow=!1},Bn)}var c,d,f,h,m,p,v,g,w,y=t[0],b={};return Kn?(V(y,\"MSPointerDown\",i),V(e,\"MSPointerMove\",r),V(e,\"MSPointerCancel\",s),V(e,\"MSPointerUp\",s)):(V(y,\"touchstart\",i),V(y,\"touchmove\",r),V(y,\"touchend\",s),V(e,\"touchstart\",u),V(e,\"touchend\",l),V(e,\"touchcancel\",l),qn.on(\"scroll\",l),t.on(\"mousedown\",i),Ln.on(\"mousemove\",r).on(\"mouseup\",s)),mo=Tn.touch?\"a\":\"div\",t.on(\"click\",mo,function(t){b.checked&&J(t)}),b}function ie(t,e){function n(n,o){S=!0,l=d=\"vertical\"===_?n._y:n._x,v=n._now,p=[[v,l]],f=h=E.noMove||o?0:x(t,(e.getPos||a)()),(e.onStart||a).call(M,n)}function i(e,o){w=E.min,y=E.max,b=E.snap,_=E.direction||\"horizontal\",t.navdir=_,k=e.altKey,S=P=!1,T=o.control,T||F.sliding||n(e)}function r(o,i){E.noSwipe||(S||n(o),d=\"vertical\"===_?o._y:o._x,p.push([o._now,d]),h=f-(l-d),m=q(h,w,y,_),w>=h?h=C(h,w):h>=y&&(h=C(h,y)),E.noMove||(t.css(c(h,_)),P||(P=!0,i.touch||Kn||t.addClass(un)),(e.onMove||a).call(M,o,{pos:h,edge:m})))}function u(i){if(!E.noSwipe||!i.moved){S||n(i.startEvent,!0),i.touch||Kn||t.removeClass(un),g=o.now();for(var r,u,l,c,m,v,x,C,T,P=g-Bn,F=null,j=Qn,z=e.friction,N=p.length-1;N>=0;N--){if(r=p[N][0],u=Math.abs(r-P),null===F||l>u)F=r,c=p[N][1];else if(F===P||u>l)break;l=u}x=s(h,w,y);var $=c-d,q=$>=0,L=g-F,A=L>Bn,I=!A&&h!==f&&x===h;b&&(x=s(Math[I?q?\"floor\":\"ceil\":\"round\"](h/b)*b,w,y),w=y=x),I&&(b||x===h)&&(T=-($/L),j*=s(Math.abs(T),e.timeLow,e.timeHigh),m=Math.round(h+T*j/z),b||(x=m),(!q&&m>y||q&&w>m)&&(v=q?w:y,C=m-v,b||(x=v),C=s(x+.03*C,v-50,v+50),j=Math.abs((h-C)/(T/z)))),j*=k?10:1,(e.onEnd||a).call(M,o.extend(i,{moved:i.moved||A&&b,pos:h,newPos:x,overPos:C,time:j,dir:_}))}}var l,d,f,h,m,p,v,g,w,y,b,_,k,T,P,S,M=t[0],F=t.data(),E={};return E=o.extend(oe(e.$wrap,o.extend({},e,{onStart:i,onMove:r,onEnd:u})),E)}function re(t,e){var n,i,r,s=t[0],u={prevent:{}};return V(s,Vn,function(t){var s=t.wheelDeltaY||-1*t.deltaY||0,l=t.wheelDeltaX||-1*t.deltaX||0,c=Math.abs(l)&&!Math.abs(s),d=Z(0>l),f=i===d,h=o.now(),m=Bn>h-r;i=d,r=h,c&&u.ok&&(!u.prevent[d]||n)&&(J(t,!0),n&&f&&m||(e.shift&&(n=!0,clearTimeout(u.t),u.t=setTimeout(function(){n=!1},Xn)),(e.onEnd||a)(t,e.shift?d:l)))}),u}function ae(){o.each(o.Fotorama.instances,function(t,e){e.index=t})}function se(t){o.Fotorama.instances.push(t),ae()}function ue(t){o.Fotorama.instances.splice(t.index,1),ae()}var le=\"fotorama\",ce=\"fotorama__fullscreen\",de=le+\"__wrap\",fe=de+\"--css2\",he=de+\"--css3\",me=de+\"--video\",pe=de+\"--fade\",ve=de+\"--slide\",ge=de+\"--no-controls\",we=de+\"--no-shadows\",ye=de+\"--pan-y\",be=de+\"--rtl\",xe=de+\"--no-captions\",_e=de+\"--toggle-arrows\",Ce=le+\"__stage\",ke=Ce+\"__frame\",Te=ke+\"--video\",Pe=Ce+\"__shaft\",Se=le+\"__grab\",Me=le+\"__pointer\",Fe=le+\"__arr\",Ee=Fe+\"--disabled\",je=Fe+\"--prev\",ze=Fe+\"--next\",Ne=le+\"__nav\",$e=Ne+\"-wrap\",qe=Ne+\"__shaft\",Le=$e+\"--vertical\",Ae=$e+\"--list\",Ie=$e+\"--horizontal\",Oe=Ne+\"--dots\",De=Ne+\"--thumbs\",Re=Ne+\"__frame\",We=le+\"__fade\",He=We+\"-front\",Ke=We+\"-rear\",Ve=le+\"__shadow\",Be=Ve+\"s\",Qe=Be+\"--left\",Xe=Be+\"--right\",Ue=Be+\"--top\",Ye=Be+\"--bottom\",Ge=le+\"__active\",Je=le+\"__select\",Ze=le+\"--hidden\",tn=le+\"--fullscreen\",en=le+\"__fullscreen-icon\",nn=le+\"__error\",on=le+\"__loading\",rn=le+\"__loaded\",an=rn+\"--full\",sn=rn+\"--img\",un=le+\"__grabbing\",ln=le+\"__img\",cn=ln+\"--full\",dn=le+\"__thumb\",fn=dn+\"__arr--left\",hn=dn+\"__arr--right\",mn=dn+\"-border\",pn=le+\"__html\",vn=le+\"-video-container\",gn=le+\"__video\",wn=gn+\"-play\",yn=gn+\"-close\",bn=le+\"__spinner\",xn=le+\"_horizontal_ratio\",_n=le+\"_vertical_ratio\",Cn=o&&o.fn.jquery.split(\".\");if(!Cn||Cn[0]<1||1==Cn[0]&&Cn[1]<8)throw\"Fotorama requires jQuery 1.8 or later and will not run without it.\";var kn={},Tn=function(t,e,n){function o(t){g.cssText=t}function i(t,e){return typeof t===e}function r(t,e){return!!~(\"\"+t).indexOf(e)}function a(t,e){for(var o in t){var i=t[o];if(!r(i,\"-\")&&g[i]!==n)return\"pfx\"==e?i:!0}return!1}function s(t,e,o){for(var r in t){var a=e[t[r]];if(a!==n)return o===!1?t[r]:i(a,\"function\")?a.bind(o||e):a}return!1}function u(t,e,n){var o=t.charAt(0).toUpperCase()+t.slice(1),r=(t+\" \"+b.join(o+\" \")+o).split(\" \");return i(e,\"string\")||i(e,\"undefined\")?a(r,e):(r=(t+\" \"+x.join(o+\" \")+o).split(\" \"),s(r,e,n))}var l,c,d,f=\"2.8.3\",h={},m=e.documentElement,p=\"modernizr\",v=e.createElement(p),g=v.style,w=({}.toString,\" -webkit- -moz- -o- -ms- \".split(\" \")),y=\"Webkit Moz O ms\",b=y.split(\" \"),x=y.toLowerCase().split(\" \"),_={},C=[],k=C.slice,T=function(t,n,o,i){var r,a,s,u,l=e.createElement(\"div\"),c=e.body,d=c||e.createElement(\"body\");if(parseInt(o,10))for(;o--;)s=e.createElement(\"div\"),s.id=i?i[o]:p+(o+1),l.appendChild(s);return r=[\"&#173;\",'<style id=\"s',p,'\">',t,\"</style>\"].join(\"\"),l.id=p,(c?l:d).innerHTML+=r,d.appendChild(l),c||(d.style.background=\"\",d.style.overflow=\"hidden\",u=m.style.overflow,m.style.overflow=\"hidden\",m.appendChild(d)),a=n(l,t),c?l.parentNode.removeChild(l):(d.parentNode.removeChild(d),m.style.overflow=u),!!a},P={}.hasOwnProperty;d=i(P,\"undefined\")||i(P.call,\"undefined\")?function(t,e){return e in t&&i(t.constructor.prototype[e],\"undefined\")}:function(t,e){return P.call(t,e)},Function.prototype.bind||(Function.prototype.bind=function(t){var e=this;if(\"function\"!=typeof e)throw new TypeError;var n=k.call(arguments,1),o=function(){if(this instanceof o){var i=function(){};i.prototype=e.prototype;var r=new i,a=e.apply(r,n.concat(k.call(arguments)));return Object(a)===a?a:r}return e.apply(t,n.concat(k.call(arguments)))};return o}),_.touch=function(){var n;return\"ontouchstart\"in t||t.DocumentTouch&&e instanceof DocumentTouch?n=!0:T([\"@media (\",w.join(\"touch-enabled),(\"),p,\")\",\"{#modernizr{top:9px;position:absolute}}\"].join(\"\"),function(t){n=9===t.offsetTop}),n},_.csstransforms3d=function(){var t=!!u(\"perspective\");return t&&\"webkitPerspective\"in m.style&&T(\"@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}\",function(e){t=9===e.offsetLeft&&3===e.offsetHeight}),t},_.csstransitions=function(){return u(\"transition\")};for(var S in _)d(_,S)&&(c=S.toLowerCase(),h[c]=_[S](),C.push((h[c]?\"\":\"no-\")+c));return h.addTest=function(t,e){if(\"object\"==typeof t)for(var o in t)d(t,o)&&h.addTest(o,t[o]);else{if(t=t.toLowerCase(),h[t]!==n)return h;e=\"function\"==typeof e?e():e,\"undefined\"!=typeof enableClasses&&enableClasses&&(m.className+=\" \"+(e?\"\":\"no-\")+t),h[t]=e}return h},o(\"\"),v=l=null,h._version=f,h._prefixes=w,h._domPrefixes=x,h._cssomPrefixes=b,h.testProp=function(t){return a([t])},h.testAllProps=u,h.testStyles=T,h.prefixed=function(t,e,n){return e?u(t,e,n):u(t,\"pfx\")},h}(t,e),Pn={ok:!1,is:function(){return!1},request:function(){},cancel:function(){},event:\"\",prefix:\"\"},Sn=\"webkit moz o ms khtml\".split(\" \");if(\"undefined\"!=typeof e.cancelFullScreen)Pn.ok=!0;else for(var Mn=0,Fn=Sn.length;Fn>Mn;Mn++)if(Pn.prefix=Sn[Mn],\"undefined\"!=typeof e[Pn.prefix+\"CancelFullScreen\"]){Pn.ok=!0;break}Pn.ok&&(Pn.event=Pn.prefix+\"fullscreenchange\",Pn.is=function(){switch(this.prefix){case\"\":return e.fullScreen;case\"webkit\":return e.webkitIsFullScreen;default:return e[this.prefix+\"FullScreen\"]}},Pn.request=function(t){return\"\"===this.prefix?t.requestFullScreen():t[this.prefix+\"RequestFullScreen\"]()},Pn.cancel=function(){return\"\"===this.prefix?e.cancelFullScreen():e[this.prefix+\"CancelFullScreen\"]()});var En,jn={lines:12,length:5,width:2,radius:7,corners:1,rotate:15,color:\"rgba(128, 128, 128, .75)\",hwaccel:!0},zn={top:\"auto\",left:\"auto\",className:\"\"};!function(t,e){En=e()}(this,function(){function t(t,n){var o,i=e.createElement(t||\"div\");for(o in n)i[o]=n[o];return i}function n(t){for(var e=1,n=arguments.length;n>e;e++)t.appendChild(arguments[e]);return t}function o(t,e,n,o){var i=[\"opacity\",e,~~(100*t),n,o].join(\"-\"),r=.01+n/o*100,a=Math.max(1-(1-t)/e*(100-r),t),s=f.substring(0,f.indexOf(\"Animation\")).toLowerCase(),u=s&&\"-\"+s+\"-\"||\"\";return m[i]||(p.insertRule(\"@\"+u+\"keyframes \"+i+\"{0%{opacity:\"+a+\"}\"+r+\"%{opacity:\"+t+\"}\"+(r+.01)+\"%{opacity:1}\"+(r+e)%100+\"%{opacity:\"+t+\"}100%{opacity:\"+a+\"}}\",p.cssRules.length),m[i]=1),i}function r(t,e){var n,o,r=t.style;for(e=e.charAt(0).toUpperCase()+e.slice(1),o=0;o<h.length;o++)if(n=h[o]+e,r[n]!==i)return n;return r[e]!==i?e:void 0}function a(t,e){for(var n in e)t.style[r(t,n)||n]=e[n];return t}function s(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)t[o]===i&&(t[o]=n[o])}return t}function u(t){for(var e={x:t.offsetLeft,y:t.offsetTop};t=t.offsetParent;)e.x+=t.offsetLeft,e.y+=t.offsetTop;return e}function l(t,e){return\"string\"==typeof t?t:t[e%t.length]}function c(t){return\"undefined\"==typeof this?new c(t):void(this.opts=s(t||{},c.defaults,v))}function d(){function e(e,n){return t(\"<\"+e+' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">',n)}p.addRule(\".spin-vml\",\"behavior:url(#default#VML)\"),c.prototype.lines=function(t,o){function i(){return a(e(\"group\",{coordsize:c+\" \"+c,coordorigin:-u+\" \"+-u}),{width:c,height:c})}function r(t,r,s){n(f,n(a(i(),{rotation:360/o.lines*t+\"deg\",left:~~r}),n(a(e(\"roundrect\",{arcsize:o.corners}),{width:u,height:o.width,left:o.radius,top:-o.width>>1,filter:s}),e(\"fill\",{color:l(o.color,t),opacity:o.opacity}),e(\"stroke\",{opacity:0}))))}var s,u=o.length+o.width,c=2*u,d=2*-(o.width+o.length)+\"px\",f=a(i(),{position:\"absolute\",top:d,left:d});if(o.shadow)for(s=1;s<=o.lines;s++)r(s,-2,\"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)\");for(s=1;s<=o.lines;s++)r(s);return n(t,f)},c.prototype.opacity=function(t,e,n,o){var i=t.firstChild;o=o.shadow&&o.lines||0,i&&e+o<i.childNodes.length&&(i=i.childNodes[e+o],i=i&&i.firstChild,i=i&&i.firstChild,i&&(i.opacity=n))}}var f,h=[\"webkit\",\"Moz\",\"ms\",\"O\"],m={},p=function(){var o=t(\"style\",{type:\"text/css\"});return n(e.getElementsByTagName(\"head\")[0],o),o.sheet||o.styleSheet}(),v={lines:12,length:7,width:5,radius:10,rotate:0,corners:1,color:\"#000\",direction:1,speed:1,trail:100,opacity:.25,fps:20,zIndex:2e9,className:\"spinner\",top:\"auto\",left:\"auto\",position:\"relative\"};c.defaults={},s(c.prototype,{spin:function(e){this.stop();var n,o,i=this,r=i.opts,s=i.el=a(t(0,{className:r.className}),{position:r.position,width:0,zIndex:r.zIndex}),l=r.radius+r.length+r.width;if(e&&(e.insertBefore(s,e.firstChild||null),o=u(e),n=u(s),a(s,{left:(\"auto\"==r.left?o.x-n.x+(e.offsetWidth>>1):parseInt(r.left,10)+l)+\"px\",top:(\"auto\"==r.top?o.y-n.y+(e.offsetHeight>>1):parseInt(r.top,10)+l)+\"px\"})),s.setAttribute(\"role\",\"progressbar\"),i.lines(s,i.opts),!f){var c,d=0,h=(r.lines-1)*(1-r.direction)/2,m=r.fps,p=m/r.speed,v=(1-r.opacity)/(p*r.trail/100),g=p/r.lines;!function w(){d++;for(var t=0;t<r.lines;t++)c=Math.max(1-(d+(r.lines-t)*g)%p*v,r.opacity),i.opacity(s,t*r.direction+h,c,r);i.timeout=i.el&&setTimeout(w,~~(1e3/m))}()}return i},stop:function(){var t=this.el;return t&&(clearTimeout(this.timeout),t.parentNode&&t.parentNode.removeChild(t),this.el=i),this},lines:function(e,i){function r(e,n){return a(t(),{position:\"absolute\",width:i.length+i.width+\"px\",height:i.width+\"px\",background:e,boxShadow:n,transformOrigin:\"left\",transform:\"rotate(\"+~~(360/i.lines*u+i.rotate)+\"deg) translate(\"+i.radius+\"px,0)\",borderRadius:(i.corners*i.width>>1)+\"px\"})}for(var s,u=0,c=(i.lines-1)*(1-i.direction)/2;u<i.lines;u++)s=a(t(),{position:\"absolute\",top:1+~(i.width/2)+\"px\",transform:i.hwaccel?\"translate3d(0,0,0)\":\"\",opacity:i.opacity,animation:f&&o(i.opacity,i.trail,c+u*i.direction,i.lines)+\" \"+1/i.speed+\"s linear infinite\"}),i.shadow&&n(s,a(r(\"#000\",\"0 0 4px #000\"),{top:\"2px\"})),n(e,n(s,r(l(i.color,u),\"0 0 1px rgba(0,0,0,.1)\")));return e},opacity:function(t,e,n){e<t.childNodes.length&&(t.childNodes[e].style.opacity=n)}});var g=a(t(\"group\"),{behavior:\"url(#default#VML)\"});return!r(g,\"transform\")&&g.adj?d():f=r(g,\"animation\"),c});var Nn,$n,qn=o(t),Ln=o(e),An=\"quirks\"===n.hash.replace(\"#\",\"\"),In=Tn.csstransforms3d,On=In&&!An,Dn=In||\"CSS1Compat\"===e.compatMode,Rn=Pn.ok,Wn=navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i),Hn=!On||Wn,Kn=navigator.msPointerEnabled,Vn=\"onwheel\"in e.createElement(\"div\")?\"wheel\":e.onmousewheel!==i?\"mousewheel\":\"DOMMouseScroll\",Bn=250,Qn=300,Xn=1400,Un=5e3,Yn=2,Gn=64,Jn=500,Zn=333,to=\"$stageFrame\",eo=\"$navDotFrame\",no=\"$navThumbFrame\",oo=\"auto\",io=r([.1,0,.25,1]),ro=1200,ao=1,so={width:null,minwidth:null,maxwidth:\"100%\",height:null,minheight:null,maxheight:null,ratio:null,margin:Yn,nav:\"dots\",navposition:\"bottom\",navwidth:null,thumbwidth:Gn,thumbheight:Gn,thumbmargin:Yn,thumbborderwidth:Yn,allowfullscreen:!1,transition:\"slide\",clicktransition:null,transitionduration:Qn,captions:!0,startindex:0,loop:!1,autoplay:!1,stopautoplayontouch:!0,keyboard:!1,arrows:!0,click:!0,swipe:!1,trackpad:!1,shuffle:!1,direction:\"ltr\",shadows:!0,spinner:null,showcaption:!0,navdir:\"horizontal\",navarrows:!0,navtype:\"thumbs\"},uo={left:!0,right:!0,down:!1,up:!1,space:!1,home:!1,end:!1};z.stop=function(t){z.ii[t]=!1};var lo,co,fo,ho,mo,po=function(){function t(t,e,n){var o=e/n;1>=o?(t.parent().removeClass(xn),t.parent().addClass(_n)):(t.parent().removeClass(_n),t.parent().addClass(xn))}function e(t,e,n){var r=n;t.attr(r)||t.attr(r)===i||t.attr(r,e),t.find(\"[\"+r+\"]\").length&&t.find(\"[\"+r+\"]\").each(function(){o(this).attr(r,e)})}function n(t,e,n){var o,i=!1;return o=t.showCaption===n||t.showCaption===!0?!0:!1,e?(t.caption&&o&&(i=!0),i):!1}return{setRatio:t,setThumbAttr:e,isExpectedCaption:n}}(po||{},jQuery);jQuery.Fotorama=function(n,r){function a(){o.each(Do,function(t,e){if(!e.i){e.i=Mi++;var n=P(e.video,!0);if(n){var o={};e.video=n,e.img||e.thumb?e.thumbsReady=!0:o=S(e,Do,ki),M(Do,{img:o.img,thumb:o.thumb},e.i,ki)}}})}function u(t){return hi[t]||ki.fullScreen}function f(){if(Ni!==i)if(\"vertical\"==r.navdir){var t=r.thumbwidth+r.thumbmargin;Ni.css(\"left\",t),Ai.css(\"right\",t),Qi.css(\"right\",t),zi.css(\"width\",zi.css(\"width\")+t),$i.css(\"max-width\",zi.width()-t)}else Ni.css(\"left\",\"\"),Ai.css(\"right\",\"\"),Qi.css(\"right\",\"\"),zi.css(\"width\",zi.css(\"width\")+t),$i.css(\"max-width\",\"\")}function m(t){var e,n=\"keydown.\"+le,o=le+Ti,i=\"keydown.\"+o,a=\"keyup.\"+o,s=\"resize.\"+o+\" orientationchange.\"+o;t?(Ln.on(i,function(t){var n,o;Ko&&27===t.keyCode?(n=!0,Mo(Ko,!0,!0)):(ki.fullScreen||r.keyboard&&!ki.index)&&(27===t.keyCode?(n=!0,ki.cancelFullScreen()):t.shiftKey&&32===t.keyCode&&u(\"space\")||37===t.keyCode&&u(\"left\")||38===t.keyCode&&u(\"up\")?(ki.longPress.progress(),o=\"<\"):32===t.keyCode&&u(\"space\")||39===t.keyCode&&u(\"right\")||40===t.keyCode&&u(\"down\")?(ki.longPress.progress(),o=\">\"):36===t.keyCode&&u(\"home\")?(ki.longPress.progress(),o=\"<<\"):35===t.keyCode&&u(\"end\")&&(ki.longPress.progress(),o=\">>\")),(n||o)&&J(t),e={index:o,slow:t.altKey,user:!0},o&&(ki.longPress.inProgress?ki.showWhileLongPress(e):ki.show(e))}),t&&Ln.on(a,function(){ki.longPress.inProgress&&ki.showEndLongPress({user:!0}),ki.longPress.reset()}),ki.index||Ln.off(n).on(n,\"textarea, input, select\",function(t){!$n.hasClass(ce)&&t.stopPropagation()}),qn.on(s,ki.resize)):(Ln.off(i),qn.off(s))}function y(t){t!==y.f&&(t?(n.addClass(le+\" \"+Pi).before(ji).before(Ei),se(ki)):(ji.detach(),Ei.detach(),n.html(Fi.urtext).removeClass(Pi),ue(ki)),m(t),y.f=t)}function b(){Do=ki.data=Do||R(r.data)||F(n),Ro=ki.size=Do.length,Oo.ok&&r.shuffle&&D(Do),a(),Zi=oe(Zi),Ro&&y(!0)}function C(){var t=2>Ro||Ko;nr.noMove=t||ai,nr.noSwipe=t||!r.swipe,!ci&&$i.toggleClass(Se,!r.click&&!nr.noMove&&!nr.noSwipe),Kn&&zi.toggleClass(ye,!nr.noSwipe)}function k(t){t===!0&&(t=\"\"),r.autoplay=Math.max(+t||Un,1.5*li)}function T(t){t.navarrows&&\"thumbs\"===t.nav?(Vi.show(),Bi.show()):(Vi.hide(),Bi.hide())}function E(t,e){return Math.floor(zi.width()/(e.thumbwidth+e.thumbmargin))}function X(){function t(t,n){e[t?\"add\":\"remove\"].push(n)}r.nav&&\"dots\"!==r.nav||(r.navdir=\"horizontal\"),ki.options=r=H(r),ao=E(zi,r),ai=\"crossfade\"===r.transition||\"dissolve\"===r.transition,ti=r.loop&&(Ro>2||ai&&(!ci||\"slide\"!==ci)),li=+r.transitionduration||Qn,fi=\"rtl\"===r.direction,hi=o.extend({},r.keyboard&&uo,r.keyboard),T(r);var e={add:[],remove:[]};Ro>1?(ei=r.nav,oi=\"top\"===r.navposition,e.remove.push(Je),Ii.toggle(r.arrows)):(ei=!1,Ii.hide()),Cn(),Ho=new En(o.extend(jn,r.spinner,zn,{direction:fi?-1:1})),Xn(),io(),Yn(),r.autoplay&&k(r.autoplay),si=h(r.thumbwidth)||Gn,ui=h(r.thumbheight)||Gn,or.ok=rr.ok=r.trackpad&&!Hn,C(),go(r,[er]),ni=\"thumbs\"===ei,Oi.filter(\":hidden\")&&ei&&Oi.show(),ni?(Sn(Ro,\"navThumb\"),Wo=Hi,Ci=no,$(Ei,o.Fotorama.jst.style({w:si,h:ui,b:r.thumbborderwidth,m:r.thumbmargin,s:Ti,q:!Dn})),Di.addClass(De).removeClass(Oe)):\"dots\"===ei?(Sn(Ro,\"navDot\"),Wo=Wi,Ci=eo,Di.addClass(Oe).removeClass(De)):(Oi.hide(),ei=!1,Di.removeClass(De+\" \"+Oe)),ei&&(oi?Oi.insertBefore(Ni):Oi.insertAfter(Ni),In.nav=!1,In(Wo,Ri,\"nav\")),ii=r.allowfullscreen,ii?(Qi.prependTo(Ni),ri=Rn&&\"native\"===ii):(Qi.detach(),ri=!1),t(ai,pe),t(!ai,ve),t(!r.captions,xe),t(fi,be),t(\"always\"!==r.arrows,_e),di=r.shadows&&!Hn,t(!di,we),zi.addClass(e.add.join(\" \")).removeClass(e.remove.join(\" \")),tr=o.extend({},r),f()}function ne(t){return 0>t?(Ro+t%Ro)%Ro:t>=Ro?t%Ro:t}function oe(t){return s(t,0,Ro-1)}function ae(t){return ti?ne(t):oe(t)}function We(t){return t>0||ti?t-1:!1}function He(t){return Ro-1>t||ti?t+1:!1}function Ke(){nr.min=ti?-1/0:-g(Ro-1,er.w,r.margin,Qo),nr.max=ti?1/0:-g(0,er.w,r.margin,Qo),nr.snap=er.w+r.margin}function Ve(){var t=\"vertical\"===r.navdir,e=t?Ri.height():Ri.width(),n=t?er.h:er.nw;ir.min=Math.min(0,n-e),ir.max=0,ir.direction=r.navdir,Ri.toggleClass(Se,!(ir.noMove=ir.min===ir.max))}function un(t,e,n){if(\"number\"==typeof t){t=new Array(t);var i=!0}return o.each(t,function(t,o){if(i&&(o=t),\"number\"==typeof o){var r=Do[ne(o)];if(r){var a=\"$\"+e+\"Frame\",s=r[a];n.call(this,t,o,r,s,a,s&&s.data())}}})}function dn(t,e,n,o){(!mi||\"*\"===mi&&o===Zo)&&(t=v(r.width)||v(t)||Jn,e=v(r.height)||v(e)||Zn,ki.resize({width:t,ratio:r.ratio||n||t/e},0,o!==Zo&&\"*\"))}function xn(t,e,n,i){un(t,e,function(t,a,s,u,l,c){function d(t){var e=ne(a);wo(t,{index:e,src:b,frame:Do[e]})}function f(){g.remove(),o.Fotorama.cache[b]=\"error\",s.html&&\"stage\"===e||!x||x===b?(!b||s.html||p?\"stage\"===e&&(u.trigger(\"f:load\").removeClass(on+\" \"+nn).addClass(rn),d(\"load\"),dn()):(u.trigger(\"f:error\").removeClass(on).addClass(nn),d(\"error\")),c.state=\"error\",!(Ro>1&&Do[a]===s)||s.html||s.deleted||s.video||p||(s.deleted=!0,ki.splice(a,1))):(s[y]=b=x,xn([a],e,n,!0))}function h(){o.Fotorama.measures[b]=w.measures=o.Fotorama.measures[b]||{width:v.width,height:v.height,ratio:v.width/v.height},dn(w.measures.width,w.measures.height,w.measures.ratio,a),g.off(\"load error\").addClass(ln+(p?\" \"+cn:\"\")).prependTo(u),u.hasClass(ke)&&!u.hasClass(vn)&&u.attr(\"href\",g.attr(\"src\")),N(g,(o.isFunction(n)?n():n)||er),o.Fotorama.cache[b]=c.state=\"loaded\",setTimeout(function(){u.trigger(\"f:load\").removeClass(on+\" \"+nn).addClass(rn+\" \"+(p?an:sn)),\"stage\"===e?d(\"load\"):(s.thumbratio===oo||!s.thumbratio&&r.thumbratio===oo)&&(s.thumbratio=w.measures.ratio,Ao())},0)}function m(){var t=10;z(function(){return!xi||!t--&&!Hn},function(){h()})}if(u){var p=ki.fullScreen&&s.full&&s.full!==s.img&&!c.$full&&\"stage\"===e;if(!c.$img||i||p){var v=new Image,g=o(v),w=g.data();c[p?\"$full\":\"$img\"]=g;var y=\"stage\"===e?p?\"full\":\"img\":\"thumb\",b=s[y],x=p?null:s[\"stage\"===e?\"thumb\":\"img\"];if(\"navThumb\"===e&&(u=c.$wrap),!b)return void f();o.Fotorama.cache[b]?!function _(){\"error\"===o.Fotorama.cache[b]?f():\"loaded\"===o.Fotorama.cache[b]?setTimeout(m,0):setTimeout(_,100)}():(o.Fotorama.cache[b]=\"*\",g.on(\"load\",m).on(\"error\",f)),c.state=\"\",v.src=b,c.data.caption&&(v.alt=c.data.caption||\"\"),po.isExpectedCaption(s,r.showcaption)&&o(v).attr(\"aria-labelledby\",s.labelledby)}}})}function _n(t){Ji.append(Ho.spin().el).appendTo(t)}function Cn(){Ji.detach(),Ho&&Ho.stop()}function kn(){var t=Vo[to];t&&!t.data().state&&(_n(t),t.on(\"f:load f:error\",function(){t.off(\"f:load f:error\"),Cn()}))}function Tn(t){Y(t,$o),G(t,function(){setTimeout(function(){W(Di)},0),co({time:li,guessIndex:o(this).data().eq,minMax:ir})})}function Sn(t,e){un(t,e,function(t,n,i,a,s,u){if(!a){a=i[s]=zi[s].clone(),u=a.data(),u.data=i;var l=a[0],c=\"labelledby\"+o.now();\"stage\"===e?(i.html&&o('<div class=\"'+pn+'\"></div>').append(i._html?o(i.html).removeAttr(\"id\").html(i._html):i.html).appendTo(a),i.id&&(c=i.id||c),i.labelledby=c,po.isExpectedCaption(i,r.showcaption)&&o(o.Fotorama.jst.frameCaption({caption:i.caption,labelledby:c})).appendTo(a),i.video&&a.addClass(Te).append(Ui.clone()),G(l,function(){setTimeout(function(){W(Ni)},0),jo({index:u.eq,user:!0})}),qi=qi.add(a)):\"navDot\"===e?(Tn(l),Wi=Wi.add(a)):\"navThumb\"===e&&(Tn(l),u.$wrap=a.children(\":first\"),Hi=Hi.add(a),i.video&&u.$wrap.append(Ui.clone()))}})}function Mn(t,e){return t&&t.length&&N(t,e)}function Fn(t){un(t,\"stage\",function(t,e,n,i,a,s){if(i){var u=ne(e);s.eq=u,sr[to][u]=i.css(o.extend({left:ai?0:g(e,er.w,r.margin,Qo)},ai&&d(0))),j(i[0])&&(i.appendTo($i),Mo(n.$video)),Mn(s.$img,er),Mn(s.$full,er),!i.hasClass(ke)||\"false\"===i.attr(\"aria-hidden\")&&i.hasClass(Ge)||i.attr(\"aria-hidden\",\"true\")}})}function An(t,e){var n,i;\"thumbs\"!==ei||isNaN(t)||(n=-t,i=-t+er.nw,\"vertical\"===r.navdir&&(t-=r.thumbheight,i=-t+er.h),Hi.each(function(){var t=o(this),a=t.data(),s=a.eq,u=function(){return{h:ui,w:a.w}},l=u(),c=\"vertical\"===r.navdir?a.t>i:a.l>i;l.w=a.w,a.l+a.w<n||c||Mn(a.$img,l)||e&&xn([s],\"navThumb\",u)}))}function In(t,e,n){if(!In[n]){var i=\"nav\"===n&&ni,a=0,s=0;e.append(t.filter(function(){for(var t,e=o(this),n=e.data(),i=0,r=Do.length;r>i;i++)if(n.data===Do[i]){t=!0,n.eq=i;break}return t||e.remove()&&!1}).sort(function(t,e){return o(t).data().eq-o(e).data().eq}).each(function(){var t=o(this),e=t.data();po.setThumbAttr(t,e.data.caption,\"aria-label\")}).each(function(){if(i){var t=o(this),e=t.data(),n=Math.round(ui*e.data.thumbratio)||si,u=Math.round(si/e.data.thumbratio)||ui;e.t=s,e.h=u,e.l=a,e.w=n,t.css({width:n}),s+=u+r.thumbmargin,a+=n+r.thumbmargin}})),In[n]=!0}}function Wn(t){return t-ur>er.w/3}function Vn(t){return!(ti||Zi+t&&Zi-Ro+t||Ko)}function Xn(){var t=Vn(0),e=Vn(1);Li.toggleClass(Ee,t).attr(U(t)),Ai.toggleClass(Ee,e).attr(U(e))}function Yn(){var t=!1,e=!1;if(\"thumbs\"!==r.navtype||r.loop||(t=0==Zi?!0:!1,e=Zi==r.data.length-1?!0:!1),\"slides\"===r.navtype){var n=l(Ri,r.navdir);t=n>=ir.max?!0:!1,e=n<=ir.min?!0:!1}Vi.toggleClass(Ee,t).attr(U(t)),Bi.toggleClass(Ee,e).attr(U(e))}function io(){or.ok&&(or.prevent={\"<\":Vn(0),\">\":Vn(1)})}function so(t){var e,n,o,i,a=t.data();ni?(e=a.l,n=a.t,o=a.w,i=a.h):(e=t.position().left,o=t.width());var s={c:e+o/2,min:-e+10*r.thumbmargin,max:-e+er.w-o-10*r.thumbmargin},u={c:n+i/2,min:-n+10*r.thumbmargin,max:-n+er.h-i-10*r.thumbmargin};return\"vertical\"===r.navdir?u:s}function lo(t){var e=Vo[Ci].data();te(Ki,{time:1.2*t,pos:\"vertical\"===r.navdir?e.t:e.l,width:e.w,height:e.h,direction:r.navdir})}function co(t){var e,n,o,i,a,u,c,d,f=Do[t.guessIndex][Ci],h=r.navtype;f&&(\"thumbs\"===h?(e=ir.min!==ir.max,o=t.minMax||e&&so(Vo[Ci]),i=e&&(t.keep&&co.t?co.l:s((t.coo||er.nw/2)-so(f).c,o.min,o.max)),a=e&&(t.keep&&co.l?co.l:s((t.coo||er.nw/2)-so(f).c,o.min,o.max)),u=\"vertical\"===r.navdir?i:a,c=e&&s(u,ir.min,ir.max)||0,n=1.1*t.time,te(Ri,{time:n,pos:c,direction:r.navdir,onEnd:function(){An(c,!0),Yn()}}),So(Di,q(c,ir.min,ir.max,r.navdir)),co.l=u):(d=l(Ri,r.navdir),n=1.11*t.time,c=Q(r,ir,t.guessIndex,d,f,Oi,r.navdir),te(Ri,{time:n,pos:c,direction:r.navdir,onEnd:function(){An(c,!0),Yn()\n}}),So(Di,q(c,ir.min,ir.max,r.navdir))))}function fo(){ho(Ci),ar[Ci].push(Vo[Ci].addClass(Ge).attr(\"data-active\",!0))}function ho(t){for(var e=ar[t];e.length;)e.shift().removeClass(Ge).attr(\"data-active\",!1)}function mo(t){var e=sr[t];o.each(Bo,function(t,n){delete e[ne(n)]}),o.each(e,function(t,n){delete e[t],n.detach()})}function vo(t){Qo=Xo=Zi;var e=Vo[to];e&&(ho(to),ar[to].push(e.addClass(Ge).attr(\"data-active\",!0)),e.hasClass(ke)&&e.attr(\"aria-hidden\",\"false\"),t||ki.showStage.onEnd(!0),x($i,0,!0),mo(to),Fn(Bo),Ke(),Ve(),Y($i[0],function(){n.hasClass(tn)||(ki.requestFullScreen(),o(Xi).trigger(\"focus\"))}))}function go(t,e){t&&o.each(e,function(e,n){n&&o.extend(n,{width:t.width||n.width,height:t.height,minwidth:t.minwidth,maxwidth:t.maxwidth,minheight:t.minheight,maxheight:t.maxheight,ratio:K(t.ratio)})})}function wo(t,e){n.trigger(le+\":\"+t,[ki,e])}function yo(){clearTimeout(bo.t),xi=1,r.stopautoplayontouch?ki.stopAutoplay():wi=!0}function bo(){xi&&(r.stopautoplayontouch||(xo(),_o()),bo.t=setTimeout(function(){xi=0},Qn+Bn))}function xo(){wi=!(!Ko&&!yi)}function _o(){if(clearTimeout(_o.t),z.stop(_o.w),!r.autoplay||wi)return void(ki.autoplay&&(ki.autoplay=!1,wo(\"stopautoplay\")));ki.autoplay||(ki.autoplay=!0,wo(\"startautoplay\"));var t=Zi,e=Vo[to].data();_o.w=z(function(){return e.state||t!==Zi},function(){_o.t=setTimeout(function(){if(!wi&&t===Zi){var e=Jo,n=Do[e][to].data();_o.w=z(function(){return n.state||e!==Jo},function(){wi||e!==Jo||ki.show(ti?Z(!fi):Jo)})}},r.autoplay)})}function Co(t){var e;return\"object\"!=typeof t?(e=t,t={}):e=t.index,e=\">\"===e?Xo+1:\"<\"===e?Xo-1:\"<<\"===e?0:\">>\"===e?Ro-1:e,e=isNaN(e)?i:e,e=\"undefined\"==typeof e?Zi||0:e}function ko(t){ki.activeIndex=Zi=ae(t),Yo=We(Zi),Go=He(Zi),Jo=ne(Zi+(fi?-1:1)),Bo=[Zi,Yo,Go],Xo=ti?t:Zi}function To(t){var e=Math.abs(Uo-Xo),n=_(t.time,function(){return Math.min(li*(1+(e-1)/12),2*li)});return t.slow&&(n*=10),n}function Po(){ki.fullScreen&&(ki.fullScreen=!1,Rn&&Pn.cancel(Si),$n.removeClass(ce),Nn.removeClass(ce),n.removeClass(tn).insertAfter(ji),er=o.extend({},bi),Mo(Ko,!0,!0),No(\"x\",!1),ki.resize(),xn(Bo,\"stage\"),W(qn,vi,pi),wo(\"fullscreenexit\"))}function So(t,e){di&&(t.removeClass(Qe+\" \"+Xe),t.removeClass(Ue+\" \"+Ye),e&&!Ko&&t.addClass(e.replace(/^|\\s/g,\" \"+Be+\"--\")))}function Mo(t,e,n){e&&(zi.removeClass(me),Ko=!1,C()),t&&t!==Ko&&(t.remove(),wo(\"unloadvideo\")),n&&(xo(),_o())}function Fo(t){zi.toggleClass(ge,t)}function Eo(t){if(!nr.flow){var e=t?t.pageX:Eo.x,n=e&&!Vn(Wn(e))&&r.click;Eo.p!==n&&Ni.toggleClass(Me,n)&&(Eo.p=n,Eo.x=e)}}function jo(t){clearTimeout(jo.t),r.clicktransition&&r.clicktransition!==r.transition?setTimeout(function(){var e=r.transition;ki.setOptions({transition:r.clicktransition}),ci=e,jo.t=setTimeout(function(){ki.show(t)},10)},0):ki.show(t)}function zo(t,e){var n=t.target,i=o(n);i.hasClass(wn)?ki.playVideo():n===Xi?ki.toggleFullScreen():Ko?n===Gi&&Mo(Ko,!0,!0):e?Fo():r.click&&jo({index:t.shiftKey||Z(Wn(t._x)),slow:t.altKey,user:!0})}function No(t,e){nr[t]=ir[t]=e}function $o(t){var e=o(this).data().eq;jo(\"thumbs\"===r.navtype?{index:e,slow:t.altKey,user:!0,coo:t._x-Di.offset().left}:{index:e,slow:t.altKey,user:!0})}function qo(t){jo({index:Ii.index(this)?\">\":\"<\",slow:t.altKey,user:!0})}function Lo(t){G(t,function(){setTimeout(function(){W(Ni)},0),Fo(!1)})}function Ao(){if(b(),X(),!Ao.i){Ao.i=!0;var t=r.startindex;Zi=Qo=Xo=Uo=Zo=ae(t)||0}if(Ro){if(Io())return;Ko&&Mo(Ko,!0),Bo=[],mo(to),Ao.ok=!0,ki.show({index:Zi,time:0}),ki.resize()}else ki.destroy()}function Io(){return!Io.f===fi?(Io.f=fi,Zi=Ro-1-Zi,ki.reverse(),!0):void 0}function Oo(){Oo.ok&&(Oo.ok=!1,wo(\"ready\"))}Nn=o(\"html\"),$n=o(\"body\");var Do,Ro,Wo,Ho,Ko,Vo,Bo,Qo,Xo,Uo,Yo,Go,Jo,Zo,ti,ei,ni,oi,ii,ri,ai,si,ui,li,ci,di,fi,hi,mi,pi,vi,gi,wi,yi,bi,xi,_i,Ci,ki=this,Ti=o.now(),Pi=le+Ti,Si=n[0],Mi=1,Fi=n.data(),Ei=o(\"<style></style>\"),ji=o(A(Ze)),zi=n.find(I(de)),Ni=zi.find(I(Ce)),$i=(Ni[0],n.find(I(Pe))),qi=o(),Li=n.find(I(je)),Ai=n.find(I(ze)),Ii=n.find(I(Fe)),Oi=n.find(I($e)),Di=Oi.find(I(Ne)),Ri=Di.find(I(qe)),Wi=o(),Hi=o(),Ki=($i.data(),Ri.data(),n.find(I(mn))),Vi=n.find(I(fn)),Bi=n.find(I(hn)),Qi=n.find(I(en)),Xi=Qi[0],Ui=o(A(wn)),Yi=n.find(I(yn)),Gi=Yi[0],Ji=o(A(bn)),Zi=!1,tr={},er={},nr={},or={},ir={},rr={},ar={},sr={},ur=0,lr=[];zi[to]=o('<div class=\"'+ke+'\"></div>'),zi[no]=o(o.Fotorama.jst.thumb()),zi[eo]=o(o.Fotorama.jst.dots()),ar[to]=[],ar[no]=[],ar[eo]=[],sr[to]={},zi.addClass(On?he:fe),Fi.fotorama=this,ki.startAutoplay=function(t){return ki.autoplay?this:(wi=yi=!1,k(t||r.autoplay),_o(),this)},ki.stopAutoplay=function(){return ki.autoplay&&(wi=yi=!0,_o()),this},ki.showSlide=function(t){var e,n=l(Ri,r.navdir),o=550,i=\"horizontal\"===r.navdir?r.thumbwidth:r.thumbheight,a=function(){Yn()};\"next\"===t&&(e=n-(i+r.margin)*ao),\"prev\"===t&&(e=n+(i+r.margin)*ao),e=B(e,ir),An(e,!0),te(Ri,{time:o,pos:e,direction:r.navdir,onEnd:a})},ki.showWhileLongPress=function(t){if(!ki.longPress.singlePressInProgress){var e=Co(t);ko(e);var n=To(t)/50,o=Vo;ki.activeFrame=Vo=Do[Zi];var i=o===Vo&&!t.user;return ki.showNav(i,t,n),this}},ki.showEndLongPress=function(t){if(!ki.longPress.singlePressInProgress){var e=Co(t);ko(e);var n=To(t)/50,o=Vo;ki.activeFrame=Vo=Do[Zi];var i=o===Vo&&!t.user;return ki.showStage(i,t,n),gi=\"undefined\"!=typeof Uo&&Uo!==Zi,Uo=Zi,this}},ki.showStage=function(t,e,n){Mo(Ko,Vo.i!==Do[ne(Qo)].i),Sn(Bo,\"stage\"),Fn(Hn?[Xo]:[Xo,We(Xo),He(Xo)]),No(\"go\",!0),t||wo(\"show\",{user:e.user,time:n}),wi=!0;var o=e.overPos,i=ki.showStage.onEnd=function(n){if(!i.ok){if(i.ok=!0,n||vo(!0),t||wo(\"showend\",{user:e.user}),!n&&ci&&ci!==r.transition)return ki.setOptions({transition:ci}),void(ci=!1);kn(),xn(Bo,\"stage\"),No(\"go\",!1),io(),Eo(),xo(),_o()}};if(ai){var a=Vo[to],s=Do[Uo]&&Zi!==Uo?Do[Uo][to]:null;ee(a,s,qi,{time:n,method:r.transition,onEnd:i},lr)}else te($i,{pos:-g(Xo,er.w,r.margin,Qo),overPos:o,time:n,onEnd:i});Xn()},ki.showNav=function(t,e,n){if(Yn(),ei){fo();var o=oe(Zi+s(Xo-Uo,-1,1));co({time:n,coo:o!==Zi&&e.coo,guessIndex:\"undefined\"!=typeof e.coo?o:Zi,keep:t}),ni&&lo(n)}},ki.show=function(t){ki.longPress.singlePressInProgress=!0;var e=Co(t);ko(e);var n=To(t),o=Vo;ki.activeFrame=Vo=Do[Zi];var i=o===Vo&&!t.user;return ki.showStage(i,t,n),ki.showNav(i,t,n),gi=\"undefined\"!=typeof Uo&&Uo!==Zi,Uo=Zi,ki.longPress.singlePressInProgress=!1,this},ki.requestFullScreen=function(){if(ii&&!ki.fullScreen){var t=o((ki.activeFrame||{}).$stageFrame||{}).hasClass(\"fotorama-video-container\");if(t)return;pi=qn.scrollTop(),vi=qn.scrollLeft(),W(qn),No(\"x\",!0),bi=o.extend({},er),n.addClass(tn).appendTo($n.addClass(ce)),Nn.addClass(ce),Mo(Ko,!0,!0),ki.fullScreen=!0,ri&&Pn.request(Si),ki.resize(),xn(Bo,\"stage\"),kn(),wo(\"fullscreenenter\")}return this},ki.cancelFullScreen=function(){return ri&&Pn.is()?Pn.cancel(e):Po(),this},ki.toggleFullScreen=function(){return ki[(ki.fullScreen?\"cancel\":\"request\")+\"FullScreen\"]()},V(e,Pn.event,function(){!Do||Pn.is()||Ko||Po()}),ki.resize=function(e){if(!Do)return this;var n=arguments[1]||0,i=arguments[2];ao=E(zi,r),go(ki.fullScreen?{width:o(t).width(),maxwidth:null,minwidth:null,height:o(t).height(),maxheight:null,minheight:null}:H(e),[er,i||ki.fullScreen||r]);var a=er.width,u=er.height,l=er.ratio,c=qn.height()-(ei?Di.height():0);if(v(a)&&(zi.css({width:\"\"}),zi.css({height:\"\"}),Ni.css({width:\"\"}),Ni.css({height:\"\"}),Ni.css({\"line-height\":\"\"}),$i.css({width:\"\"}),$i.css({height:\"\"}),Di.css({width:\"\"}),Di.css({height:\"\"}),zi.css({minWidth:er.minwidth||0,maxWidth:er.maxwidth||ro}),a=er.W=er.w=zi.width(),er.nw=ei&&p(r.navwidth,a)||a,$i.css({width:er.w,marginLeft:(er.W-er.w)/2}),u=p(u,c),u=u||l&&a/l)){if(a=Math.round(a),u=er.h=Math.round(s(u,p(er.minheight,c),p(er.maxheight,c))),Ni.css({width:a,height:u,\"line-height\":u+\"px\"}),\"vertical\"!==r.navdir||ki.fullscreen||Di.width(r.thumbwidth+2*r.thumbmargin),\"horizontal\"!==r.navdir||ki.fullscreen||Di.height(r.thumbheight+2*r.thumbmargin),\"vertical\"===r.navdir&&ki.fullScreen&&Ni.css(\"height\",o(t).height()),\"horizontal\"===r.navdir&&ki.fullScreen&&Ni.css(\"height\",o(t).height()-(r.thumbheight+2*r.thumbmargin)),ei){switch(r.navdir){case\"vertical\":Oi.removeClass(Ie),Oi.removeClass(Ae),Oi.addClass(Le),Di.stop().animate({height:er.h,width:r.thumbwidth},n);break;case\"list\":Oi.removeClass(Le),Oi.removeClass(Ie),Oi.addClass(Ae);break;default:Oi.removeClass(Le),Oi.removeClass(Ae),Oi.addClass(Ie),Di.stop().animate({width:er.nw},n)}vo(),co({guessIndex:Zi,time:n,keep:!0}),ni&&In.nav&&lo(n)}mi=i||!0,Oo.ok=!0,Oo()}return ur=Ni.offset().left,f(),this},ki.setOptions=function(t){return o.extend(r,t),Ao(),this},ki.shuffle=function(){return Do&&D(Do)&&Ao(),this},ki.longPress={threshold:1,count:0,thumbSlideTime:20,progress:function(){this.inProgress||(this.count++,this.inProgress=this.count>this.threshold)},end:function(){this.inProgress&&(this.isEnded=!0)},reset:function(){this.count=0,this.inProgress=!1,this.isEnded=!1}},ki.destroy=function(){return ki.cancelFullScreen(),ki.stopAutoplay(),Do=ki.data=null,y(),Bo=[],mo(to),Ao.ok=!1,this},ki.playVideo=function(){var t=Vo,e=t.video,n=Zi;return\"object\"==typeof e&&t.videoReady&&(ri&&ki.fullScreen&&ki.cancelFullScreen(),z(function(){return!Pn.is()||n!==Zi},function(){n===Zi&&(t.$video=t.$video||o(A(gn)).append(O(e)),t.$video.appendTo(t[to]),zi.addClass(me),Ko=t.$video,C(),Ii.blur(),Qi.blur(),wo(\"loadvideo\"))})),this},ki.stopVideo=function(){return Mo(Ko,!0,!0),this},Ni.on(\"mousemove\",Eo),nr=ie($i,{onStart:yo,onMove:function(t,e){So(Ni,e.edge)},onTouchEnd:bo,onEnd:function(t){var e;if(So(Ni),e=(Kn&&!_i||t.touch)&&r.arrows&&\"always\"!==r.arrows,(t.moved||e&&t.pos!==t.newPos&&!t.control)&&t.$target[0]!==Qi[0]){var n=w(t.newPos,er.w,r.margin,Qo);ki.show({index:n,time:ai?li:t.time,overPos:t.overPos,user:!0})}else t.aborted||t.control||zo(t.startEvent,e)},timeLow:1,timeHigh:1,friction:2,select:\".\"+Je+\", .\"+Je+\" *\",$wrap:Ni,direction:\"horizontal\"}),ir=ie(Ri,{onStart:yo,onMove:function(t,e){So(Di,e.edge)},onTouchEnd:bo,onEnd:function(t){function e(){co.l=t.newPos,xo(),_o(),An(t.newPos,!0),Yn()}if(t.moved)t.pos!==t.newPos?(wi=!0,te(Ri,{time:t.time,pos:t.newPos,overPos:t.overPos,direction:r.navdir,onEnd:e}),An(t.newPos),di&&So(Di,q(t.newPos,ir.min,ir.max,t.dir))):e();else{var n=t.$target.closest(\".\"+Re,Ri)[0];n&&$o.call(n,t.startEvent)}},timeLow:.5,timeHigh:2,friction:5,$wrap:Di,direction:r.navdir}),or=re(Ni,{shift:!0,onEnd:function(t,e){yo(),bo(),ki.show({index:e,slow:t.altKey})}}),rr=re(Di,{onEnd:function(t,e){yo(),bo();var n=x(Ri)+.25*e;Ri.css(c(s(n,ir.min,ir.max),r.navdir)),di&&So(Di,q(n,ir.min,ir.max,r.navdir)),rr.prevent={\"<\":n>=ir.max,\">\":n<=ir.min},clearTimeout(rr.t),rr.t=setTimeout(function(){co.l=n,An(n,!0)},Bn),An(n)}}),zi.hover(function(){setTimeout(function(){xi||Fo(!(_i=!0))},0)},function(){_i&&Fo(!(_i=!1))}),L(Ii,function(t){J(t),qo.call(this,t)},{onStart:function(){yo(),nr.control=!0},onTouchEnd:bo}),L(Vi,function(t){J(t),\"thumbs\"===r.navtype?ki.show(\"<\"):ki.showSlide(\"prev\")}),L(Bi,function(t){J(t),\"thumbs\"===r.navtype?ki.show(\">\"):ki.showSlide(\"next\")}),Ii.each(function(){Y(this,function(t){qo.call(this,t)}),Lo(this)}),Y(Xi,function(){ki.toggleFullScreen(),o(Xi).trigger(\"focus\")}),Lo(Xi),o.each(\"load push pop shift unshift reverse sort splice\".split(\" \"),function(t,e){ki[e]=function(){return Do=Do||[],\"load\"!==e?Array.prototype[e].apply(Do,arguments):arguments[0]&&\"object\"==typeof arguments[0]&&arguments[0].length&&(Do=R(arguments[0])),Ao(),ki}}),Ao()},o.fn.fotorama=function(e){return this.each(function(){var n=this,i=o(this),r=i.data(),a=r.fotorama;a?a.setOptions(e,!0):z(function(){return!E(n)},function(){r.urtext=i.html(),new o.Fotorama(i,o.extend({},so,t.fotoramaDefaults,e,r))})})},o.Fotorama.instances=[],o.Fotorama.cache={},o.Fotorama.measures={},o=o||{},o.Fotorama=o.Fotorama||{},o.Fotorama.jst=o.Fotorama.jst||{},o.Fotorama.jst.dots=function(){{var t=\"\";kn.escape}return t+='<div class=\"fotorama__nav__frame fotorama__nav__frame--dot\" tabindex=\"0\" role=\"button\" data-gallery-role=\"nav-frame\" data-nav-type=\"thumb\" aria-label>\\r\\n    <div class=\"fotorama__dot\"></div>\\r\\n</div>'},o.Fotorama.jst.frameCaption=function(t){{var e,n=\"\";kn.escape}return n+='<div class=\"fotorama__caption\" aria-hidden=\"true\">\\r\\n    <div class=\"fotorama__caption__wrap\" id=\"'+(null==(e=t.labelledby)?\"\":e)+'\">'+(null==(e=t.caption)?\"\":e)+\"</div>\\r\\n</div>\\r\\n\"},o.Fotorama.jst.style=function(t){{var e,n=\"\";kn.escape}return n+=\".fotorama\"+(null==(e=t.s)?\"\":e)+\" .fotorama__nav--thumbs .fotorama__nav__frame{\\r\\npadding:\"+(null==(e=t.m)?\"\":e)+\"px;\\r\\nheight:\"+(null==(e=t.h)?\"\":e)+\"px}\\r\\n.fotorama\"+(null==(e=t.s)?\"\":e)+\" .fotorama__thumb-border{\\r\\nheight:\"+(null==(e=t.h)?\"\":e)+\"px;\\r\\nborder-width:\"+(null==(e=t.b)?\"\":e)+\"px;\\r\\nmargin-top:\"+(null==(e=t.m)?\"\":e)+\"px}\"},o.Fotorama.jst.thumb=function(){{var t=\"\";kn.escape}return t+='<div class=\"fotorama__nav__frame fotorama__nav__frame--thumb\" tabindex=\"0\" role=\"button\" data-gallery-role=\"nav-frame\" data-nav-type=\"thumb\" aria-label>\\r\\n    <div class=\"fotorama__thumb\">\\r\\n    </div>\\r\\n</div>'}}(window,document,location,\"undefined\"!=typeof jQuery&&jQuery);"}
    }
});
